<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DonkeyChat - Secure P2P</title>
    <meta name="description" content="Encrypted P2P chat and file transfer. No accounts, no traces, no server storage.">
    <meta name="theme-color" content="#09090b">
    <link rel="manifest" href="/manifest.json">
    <link rel="icon" href="/icon-192.svg" type="image/svg+xml">
    <link rel="apple-touch-icon" href="/icon-192.svg">
    <script src="https://cdn.jsdelivr.net/npm/qrcode-generator@1.4.4/qrcode.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js"></script>
    <style>
        :root {
            --bg-color: #09090b;
            --surface: #18181b;
            --surface-hover: #27272a;
            --border: #3f3f46;
            --text-main: #fafafa;
            --text-muted: #a1a1aa;
            --brand-red: #ef4444;
            --brand-red-hover: #dc2626;
            --red-glow: rgba(239, 68, 68, 0.15);
            --green: #22c55e;
            --radius-md: 12px;
            --radius-lg: 16px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-color);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #2b2b33;
        }

        ::-webkit-scrollbar-corner {
            background: var(--bg-color);
        }

        ::-webkit-scrollbar-button {
            display: none;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Inter', 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-color);
            color: var(--text-main);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            line-height: 1.5;
        }

        .container {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: var(--radius-lg);
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5), 0 0 40px var(--red-glow);
            max-width: 540px;
            width: 100%;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* --- HEADER --- */
        /* Discovery Peer Cards */
        .peer-card {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 12px;
            cursor: pointer;
            transition: 0.2s;
        }

        .peer-card:hover {
            border-color: var(--brand-red);
            background: var(--surface-hover);
        }

        .header {
            padding: 28px 32px 20px;
            text-align: center;
            border-bottom: 1px solid var(--border);
        }

        .header h1 {
            font-size: 22px;
            font-weight: 700;
            letter-spacing: -0.5px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .header p {
            color: var(--text-muted);
            font-size: 13px;
            margin-top: 6px;
        }

        .traffic-badge {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            background: rgba(34, 197, 94, 0.1);
            color: var(--text-main);
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            border: 1px solid rgba(34, 197, 94, 0.2);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .traffic-pill {
            display: flex;
            align-items: center;
            gap: 6px;
            color: var(--green);
        }

        .traffic-dot {
            width: 6px;
            height: 6px;
            background: var(--green);
            border-radius: 50%;
            box-shadow: 0 0 6px var(--green);
        }

        /* --- SCREENS --- */
        #setupScreen {
            padding: 28px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        #chatScreen {
            display: none;
            padding: 0;
            height: 600px;
            flex-direction: column;
            position: relative;
        }

        /* --- INPUTS --- */
        .input-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .input-group label {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        input[type="text"] {
            width: 100%;
            background: var(--bg-color);
            border: 1px solid var(--border);
            color: var(--text-main);
            padding: 13px 16px;
            border-radius: var(--radius-md);
            font-size: 15px;
            transition: all 0.2s ease;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: var(--brand-red);
            box-shadow: 0 0 0 3px var(--red-glow);
        }

        input[type="text"]:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* --- BUTTONS --- */
        .btn-row {
            display: flex;
            gap: 12px;
        }

        button {
            padding: 13px 20px;
            border: none;
            border-radius: var(--radius-md);
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-primary {
            background: var(--brand-red);
            color: white;
            flex: 2;
        }

        .btn-primary:hover:not(:disabled) {
            background: var(--brand-red-hover);
        }

        .btn-secondary {
            background: var(--bg-color);
            color: var(--text-main);
            border: 1px solid var(--border);
            flex: 1;
        }

        .btn-secondary:hover:not(:disabled) {
            background: var(--surface-hover);
            border-color: #52525b;
        }

        /* --- CODE BOX --- */
        .code-box {
            background: var(--bg-color);
            border: 1px solid var(--border);
            border-radius: var(--radius-md);
            padding: 20px;
            text-align: center;
        }

        .code-digits {
            font-family: 'Courier New', monospace;
            font-size: 44px;
            font-weight: 700;
            letter-spacing: 8px;
            color: var(--brand-red);
            margin: 10px 0 6px;
            text-shadow: 0 0 20px rgba(239, 68, 68, 0.2);
        }

        .code-timer {
            font-size: 12px;
            color: var(--text-muted);
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }

        .code-timer.urgent {
            color: #f97316;
        }

        .code-timer.critical {
            color: var(--brand-red);
            animation: pulse 1s infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1
            }

            50% {
                opacity: 0.5
            }
        }

        .join-form {
            display: flex;
            gap: 8px;
        }

        .join-form input {
            text-align: center;
            letter-spacing: 4px;
            font-weight: 600;
            font-size: 18px;
        }

        /* --- STATUS --- */
        .info-box {
            background: rgba(239, 68, 68, 0.05);
            border: 1px solid rgba(239, 68, 68, 0.2);
            padding: 14px 16px;
            border-radius: var(--radius-md);
            font-size: 13px;
            color: #fca5a5;
            line-height: 1.6;
        }

        .info-box span {
            color: var(--brand-red);
            font-weight: bold;
        }

        /* WebRTC mode badge */
        .mode-badge {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            font-size: 11px;
            font-weight: 600;
            padding: 3px 8px;
            border-radius: 20px;
            background: rgba(34, 197, 94, 0.1);
            color: var(--green);
            border: 1px solid rgba(34, 197, 94, 0.25);
        }

        .mode-badge.relay {
            background: rgba(239, 68, 68, 0.1);
            color: #f87171;
            border-color: rgba(239, 68, 68, 0.25);
        }

        .mode-badge.connecting {
            background: rgba(251, 191, 36, 0.1);
            color: #fbbf24;
            border-color: rgba(251, 191, 36, 0.25);
        }

        .status-text {
            font-size: 13px;
            font-weight: 500;
            color: var(--text-muted);
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--text-muted);
            flex-shrink: 0;
        }

        .status-dot.active {
            background: var(--green);
            box-shadow: 0 0 10px rgba(34, 197, 94, 0.4);
        }

        .status-dot.error {
            background: var(--brand-red);
        }

        /* --- CHAT SCREEN --- */
        .chat-header {
            padding: 16px 20px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--surface);
            gap: 10px;
        }

        .chat-header-left {
            display: flex;
            flex-direction: column;
            gap: 4px;
            min-width: 0;
        }

        .chat-header-left h3 {
            font-size: 15px;
            font-weight: 600;
        }

        .chat-header-meta {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        .chat-header-meta p {
            font-size: 12px;
            color: var(--text-muted);
            white-space: nowrap;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 14px;
            background: var(--bg-color);
        }

        .chat-messages::-webkit-scrollbar {
            width: 5px;
        }

        .chat-messages::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 10px;
        }

        .msg-wrapper {
            display: flex;
            flex-direction: column;
            max-width: 80%;
        }

        .msg-wrapper.sent {
            align-self: flex-end;
            align-items: flex-end;
        }

        .msg-wrapper.received {
            align-self: flex-start;
            align-items: flex-start;
        }

        .msg-nick {
            font-size: 11px;
            font-weight: 600;
            color: var(--text-muted);
            margin-bottom: 3px;
            padding: 0 4px;
        }

        .msg {
            padding: 11px 15px;
            border-radius: 16px;
            font-size: 14px;
            line-height: 1.5;
            word-wrap: break-word;
            white-space: pre-wrap;
            position: relative;
        }

        .msg-wrapper.sent .msg {
            background: var(--brand-red);
            color: white;
            border-bottom-right-radius: 4px;
        }

        .msg-wrapper.received .msg {
            background: var(--surface);
            border: 1px solid var(--border);
            color: var(--text-main);
            border-bottom-left-radius: 4px;
        }

        /* Read receipt */
        .msg-meta {
            display: flex;
            align-items: center;
            gap: 4px;
            margin-top: 3px;
            padding: 0 4px;
        }

        .msg-time {
            font-size: 10px;
            color: var(--text-muted);
        }

        .read-tick {
            font-size: 12px;
            color: var(--text-muted);
            transition: color 0.3s;
            line-height: 1;
        }

        .read-tick.seen {
            color: #60a5fa;
        }

        .msg.system {
            align-self: center;
            background: transparent;
            color: var(--text-muted);
            font-size: 11px;
            font-weight: 500;
            padding: 6px 14px;
            border: 1px dashed var(--border);
            border-radius: 20px;
            max-width: 90%;
            text-align: center;
            margin: 4px 0;
        }

        .chat-input-area {
            padding: 16px 20px;
            background: var(--surface);
            border-top: 1px solid var(--border);
            display: flex;
            gap: 10px;
            align-items: flex-end;
        }

        .chat-input-area textarea {
            flex: 1;
            padding: 12px 16px;
            background: var(--bg-color);
            border: 1px solid var(--border);
            border-radius: 20px;
            color: white;
            font-size: 14px;
            transition: border-color 0.2s;
            resize: none;
            font-family: inherit;
            overflow-y: auto;
            max-height: 150px;
            min-height: 44px;
            box-sizing: border-box;
            line-height: 1.4;
        }

        .chat-input-area textarea:focus {
            outline: none;
            border-color: var(--brand-red);
        }

        .btn-icon {
            width: 42px;
            height: 42px;
            border-radius: 50%;
            background: var(--bg-color);
            border: 1px solid var(--border);
            color: var(--text-main);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            flex-shrink: 0;
            transition: 0.2s;
            font-size: 16px;
        }

        .btn-icon:hover:not(:disabled) {
            background: var(--surface-hover);
            color: var(--brand-red);
        }

        .btn-send {
            background: var(--brand-red);
            border: none;
            color: white;
        }

        .btn-send:hover:not(:disabled) {
            background: var(--brand-red-hover);
            color: white;
        }

        /* File UI */
        .file-msg {
            display: flex;
            flex-direction: column;
            align-items: stretch;
            width: 280px;
            /* Ensure cards are compact on mobile */
            max-width: 100%;
            white-space: normal;
        }

        .file-msg-header {
            display: flex;
            align-items: flex-start;
            gap: 12px;
        }

        .file-icon {
            font-size: 26px;
            flex-shrink: 0;
            margin-top: 2px;
        }

        .file-info {
            flex: 1;
            min-width: 0;
        }

        .file-name {
            font-weight: 600;
            font-size: 13px;
            word-break: break-all;
            line-height: 1.3;
        }

        .file-meta {
            font-size: 11px;
            opacity: 0.75;
            margin-top: 3px;
        }

        /* Accept / Decline buttons */
        .file-actions {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }

        .btn-accept {
            flex: 1;
            padding: 8px 0;
            background: var(--green);
            color: #000;
            border: none;
            border-radius: 8px;
            font-size: 12px;
            font-weight: 700;
            cursor: pointer;
            transition: opacity 0.2s;
        }

        .btn-accept:hover {
            opacity: 0.85;
        }

        .btn-decline {
            flex: 1;
            padding: 8px 0;
            background: transparent;
            color: #f87171;
            border: 1px solid rgba(239, 68, 68, 0.4);
            border-radius: 8px;
            font-size: 12px;
            font-weight: 700;
            cursor: pointer;
            transition: background 0.2s;
        }

        .btn-decline:hover {
            background: rgba(239, 68, 68, 0.1);
        }

        .msg-wrapper.sent .btn-decline {
            color: rgba(255, 255, 255, 0.9);
            border-color: rgba(255, 255, 255, 0.4);
        }

        .msg-wrapper.sent .btn-decline:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        /* Progress */
        .progress-wrap {
            margin-top: 10px;
            height: 4px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            width: 0%;
            transition: width 0.12s linear;
        }

        .msg-wrapper.sent .progress-bar {
            background: rgba(255, 255, 255, 0.75);
        }

        .msg-wrapper.received .progress-bar {
            background: var(--green);
        }

        .msg-wrapper.received .progress-wrap {
            background: rgba(0, 0, 0, 0.15);
        }

        .progress-stats {
            display: flex;
            justify-content: space-between;
            margin-top: 5px;
            font-size: 10px;
            opacity: 0.7;
        }

        /* Transfer mode label */
        .transfer-mode {
            font-size: 10px;
            opacity: 0.65;
            margin-top: 4px;
        }

        .hidden {
            display: none !important;
        }

        /* Drag Overlay */
        .drag-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(9, 9, 11, 0.85);
            backdrop-filter: blur(4px);
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            color: var(--brand-red);
            font-size: 20px;
            font-weight: 600;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
            border: 2px dashed var(--brand-red);
            border-radius: var(--radius-lg);
            margin: 10px;
        }

        #chatScreen.drag-active .drag-overlay {
            opacity: 1;
        }

        /* QR Code Display */
        .qr-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            margin: 12px 0 6px;
        }

        .qr-container img,
        .qr-container canvas {
            border-radius: 12px;
            background: white;
            padding: 10px;
        }

        .qr-label {
            font-size: 11px;
            color: var(--text-muted);
        }

        /* QR Scanner Overlay */
        .qr-scanner-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            gap: 16px;
        }

        .qr-scanner-overlay video {
            width: 300px;
            height: 300px;
            object-fit: cover;
            border-radius: 16px;
            border: 2px solid var(--brand-red);
        }

        .qr-scanner-overlay .scanner-title {
            color: white;
            font-size: 16px;
            font-weight: 600;
        }

        .qr-scanner-overlay .btn-secondary {
            margin-top: 8px;
        }

        /* Scan QR button */
        .btn-scan {
            padding: 8px 14px;
            font-size: 12px;
            background: var(--surface);
            border: 1px solid var(--border);
            color: var(--text-main);
            border-radius: var(--radius-md);
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 5px;
            transition: 0.2s;
        }

        .btn-scan:hover {
            background: var(--surface-hover);
            border-color: var(--brand-red);
        }

        /* Image Messages */
        .msg.image-msg {
            padding: 4px;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .chat-image {
            max-width: 260px;
            max-height: 260px;
            border-radius: 14px;
            cursor: pointer;
            object-fit: cover;
            width: 100%;
            display: block;
            transition: opacity 0.2s;
        }

        .msg.sent.image-msg .chat-image {
            border-bottom-right-radius: 4px;
        }

        .msg.received.image-msg .chat-image {
            border-bottom-left-radius: 4px;
        }

        .chat-image:hover {
            opacity: 0.9;
        }

        .img-download-btn {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            font-size: 11px;
            color: var(--text-muted);
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 6px;
            background: transparent;
            border: 1px solid var(--border);
            margin-top: 6px;
            transition: 0.2s;
        }

        .img-download-btn:hover {
            background: var(--surface-hover);
            color: var(--text-main);
        }

        .msg-wrapper.sent .img-download-btn {
            border-color: rgba(255, 255, 255, 0.3);
            color: rgba(255, 255, 255, 0.7);
        }

        .msg-wrapper.sent .img-download-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }

        /* LAN Mode Toggle */
        .lan-section {
            margin-top: 12px;
            padding: 14px;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: var(--radius-md);
        }

        .lan-toggle {
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            user-select: none;
        }

        .lan-toggle-label {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            font-weight: 600;
        }

        .switch {
            position: relative;
            width: 40px;
            height: 22px;
            background: var(--border);
            border-radius: 22px;
            transition: 0.3s;
            flex-shrink: 0;
        }

        .switch::after {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            background: white;
            border-radius: 50%;
            top: 3px;
            left: 3px;
            transition: 0.3s;
        }

        .switch.active {
            background: var(--green);
        }

        .switch.active::after {
            left: 21px;
        }

        .lan-input-row {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }

        .lan-input-row input {
            flex: 1;
            padding: 8px 12px;
            background: var(--bg-color);
            border: 1px solid var(--border);
            border-radius: var(--radius-md);
            color: white;
            font-size: 13px;
        }

        .lan-input-row input:focus {
            outline: none;
            border-color: var(--green);
        }

        .lan-hint {
            font-size: 11px;
            color: var(--text-muted);
            margin-top: 8px;
            line-height: 1.5;
        }

        .mode-badge.lan {
            background: rgba(34, 197, 94, 0.15);
            color: var(--green);
            border-color: rgba(34, 197, 94, 0.3);
        }

        /* Image view overlay */
        .img-viewer-overlay {
            position: fixed;
            inset: 0;
            z-index: 9999;
            background: rgba(0, 0, 0, 0.92);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: zoom-out;
        }

        .img-viewer-overlay img {
            max-width: 95vw;
            max-height: 90vh;
            object-fit: contain;
            border-radius: 8px;
        }
    </style>
</head>

<body>
    <!-- Traffic counter at top-left -->
    <div class="traffic-badge" id="trafficBadge" style="display: none;">
        <span>Current Traffic</span>
        <div class="traffic-pill">
            <span class="traffic-dot"></span>
            <span id="trafficCount">1</span> Online
        </div>
    </div>

    <div class="container">
        <div class="header">
            <h1>ü´è DonkeyChat</h1>
            <p>Encrypted P2P network. Zero traces.</p>
        </div>

        <div id="setupScreen">
            <div class="status-text" id="serverStatus">
                <div class="status-dot"></div> Connecting to relay server... (takes 30-50s max)
            </div>

            <div class="input-group">
                <label>Nickname</label>
                <input type="text" id="nickInput" placeholder="Enter your display name..." maxlength="20"
                    oninput="onNickInput()">
            </div>

            <div class="btn-row">
                <button class="btn-primary" id="createBtn" onclick="createRoom()" disabled>Create Secure Room</button>
                <button class="btn-secondary" id="joinBtn" onclick="toggleJoin()" disabled>Join Room</button>
            </div>

            <div id="codeBox" class="code-box hidden">
                <div class="status-text">
                    <div class="status-dot active"></div> Room Active ‚Äî Share code or QR with peer
                </div>
                <div class="code-digits" id="codeDisplay">------</div>
                <div class="qr-container" id="qrContainer"></div>
                <div class="code-timer" id="codeTimer">‚è± Expires in 10:00</div>
                <button class="btn-secondary" style="width:100%;" onclick="copyCode()">üìã Copy Passcode</button>
            </div>

            <div id="joinSection" class="hidden">
                <div class="input-group">
                    <label>Enter Room Passcode</label>
                    <div class="join-form">
                        <input type="text" id="joinInput" placeholder="000000" maxlength="6" inputmode="numeric"
                            oninput="this.value=this.value.replace(/\D/g,'')">
                        <button class="btn-primary" style="flex:0 0 auto;" onclick="joinRoom()">Connect</button>
                    </div>
                    <button class="btn-scan" onclick="openQRScanner()">üì∑ Scan QR Code</button>
                </div>
                <div id="joinStatus" style="margin-top:10px;"></div>
            </div>

            <div id="discoverySection" class="hidden" style="margin-top:20px; text-align:left;">
                <h3 style="font-size:14px; color:var(--text-muted); margin-bottom:12px; font-weight:500;">Nearby Devices
                </h3>
                <div id="peerList" style="display:flex; flex-direction:column; gap:8px;"></div>
            </div>

            <div class="info-box">
                <span>How it works:</span> Chat uses my relay server. Files transfer <strong>directly P2P via
                    WebRTC</strong> ‚Äî my server never sees file data. If WebRTC fails, files fall back through the
                relay. Max file size: <strong>4GB+</strong> (WebRTC) / 100MB (relay fallback). Room codes expire in
                <strong>10 minutes</strong>.
            </div>
        </div>

        <div id="chatScreen">
            <div class="chat-header">
                <div class="chat-header-left">
                    <h3>Secure Session</h3>
                    <div class="chat-header-meta">
                        <p id="chatSubtext">üü¢ Connected</p>
                        <span id="connectionModeBadge" class="mode-badge connecting">‚ö° Connecting...</span>
                    </div>
                </div>
                <button class="btn-secondary" style="padding:8px 12px;font-size:12px;flex:none;"
                    onclick="disconnect()">End Session</button>
            </div>

            <div class="chat-messages" id="chatMessages"></div>

            <div class="chat-input-area">
                <button class="btn-icon" id="attachBtn" onclick="pickFile()" disabled title="Send File">üìé</button>
                <button class="btn-icon" id="imgBtn" onclick="pickImage()" disabled title="Send Image">üñºÔ∏è</button>
                <textarea id="msgInput" placeholder="Type a secure message..." onkeydown="onKey(event)"
                    oninput="this.style.height='auto';this.style.height=(this.scrollHeight)+'px';" rows="1"
                    disabled></textarea>
                <button class="btn-icon btn-send" id="sendBtn" onclick="sendMessage()" disabled title="Send">
                    <img src="https://github.com/Tawhid-exe/chat/blob/main/sendicon.png?raw=true" alt="Send"
                        style="width:26px;height:26px;object-fit:contain;transform:translateX(-1px);">
                </button>
            </div>
            <input type="file" id="fileInput" class="hidden" onchange="sendFile()">
            <input type="file" id="imageInput" class="hidden" accept="image/*" onchange="sendImageFile()">
            <div class="drag-overlay">
                <div>üìÅ Drop File to Send</div>
            </div>
        </div>
    </div>

    <script>
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        //  CONFIG
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        const REMOTE_WS_URL = 'wss://chat-st99.onrender.com';
        let WS_URL = REMOTE_WS_URL;
        const CODE_TTL = 10 * 60 * 1000; // 10 minutes
        const CHUNK_SIZE_DEFAULT = 64 * 1024;   // 64KB for internet
        const CHUNK_SIZE_LAN = 256 * 1024;      // 256KB for LAN (max speed)
        let CHUNK = CHUNK_SIZE_DEFAULT;

        let viaDiscovery = false;
        let myPeerId = Math.random().toString(36).substr(2, 9);
        let nickTimeout = null;

        // ICE servers: multiple STUN + TURN fallbacks
        // Priority: Google STUN (free, unlimited) ‚Üí OpenRelay TURN ‚Üí ExpressTURN ‚Üí Cloudflare TURN
        const ICE_SERVERS = [
            // Google STUN ‚Äî always free, unlimited
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun1.l.google.com:19302' },
            { urls: 'stun:stun2.l.google.com:19302' },
            { urls: 'stun:stun3.l.google.com:19302' },
            { urls: 'stun:stun4.l.google.com:19302' },
            // OpenRelay (Metered) ‚Äî 20GB/month free TURN, ports 80/443, SSL bypass
            {
                urls: 'stun:openrelay.metered.ca:80'
            },
            {
                urls: 'turn:openrelay.metered.ca:80',
                username: 'openrelayproject',
                credential: 'openrelayproject'
            },
            {
                urls: 'turn:openrelay.metered.ca:443',
                username: 'openrelayproject',
                credential: 'openrelayproject'
            },
            {
                urls: 'turn:openrelay.metered.ca:443?transport=tcp',
                username: 'openrelayproject',
                credential: 'openrelayproject'
            },
            // ExpressTURN ‚Äî 1000GB/month free
            {
                urls: 'stun:stun.expressturn.com:3478'
            },
            {
                urls: 'turn:stun.expressturn.com:3478',
                username: 'efUN6XXXXXXXXXXX',   // placeholder ‚Äî works without for STUN
                credential: 'expressturn'
            },
            // Cloudflare STUN (public)
            { urls: 'stun:stun.cloudflare.com:3478' },
            // Additional public STUN servers
            { urls: 'stun:stun.stunprotocol.org:3478' },
            { urls: 'stun:stun.voip.blackberry.com:3478' },
            { urls: 'stun:stun.nextcloud.com:443' },
        ];

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        //  STATE
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        let ws = null;
        let myCode = '';
        let connected = false;
        let myNick = '';
        let peerNick = 'Peer';
        let codeCreatedAt = null;
        let timerInterval = null;
        let chatVisible = false;  // tracks if chat screen is already shown
        let lanMode = false;      // LAN mode active

        // WebRTC state
        let pc = null;           // RTCPeerConnection
        let dataChannel = null;  // RTCDataChannel for files
        let isInitiator = false; // true = room creator
        let rtcConnected = false;
        let usingRTC = false;    // true = WebRTC data channel active
        let rtcFallbackTimer = null; // timer to detect RTC failure

        // File transfer state
        let incomingMeta = null;
        let incomingChunks = [];
        let incomingCount = 0;
        // Pending outgoing transfers waiting for receiver acceptance
        // fileId ‚Üí { buf, meta, useRTC }
        let pendingOutgoing = {};
        // Speed tracking per transfer
        // fileId ‚Üí { startTime, bytesTransferred, aborted }
        let transferStats = {};

        // Read receipts: msgId ‚Üí DOM element
        let sentMsgMap = {};
        let msgIdCounter = 0;

        // QR scanner state
        let qrScannerStream = null;
        let qrScanInterval = null;

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        //  WEBSOCKET ‚Äî Signaling + Chat + Fallback
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        function connectWS() {
            ws = new WebSocket(WS_URL);

            ws.onopen = () => {
                const stat = document.getElementById('serverStatus');
                stat.innerHTML = '<div class="status-dot active"></div> Relay Server Online';
                document.getElementById('createBtn').disabled = false;
                document.getElementById('joinBtn').disabled = false;
            };

            ws.onmessage = (e) => {
                let msg;
                try { msg = JSON.parse(e.data); } catch { return; }
                onServerMsg(msg);
            };

            ws.onclose = () => {
                if (connected) sysMsg('Connection to relay lost.');
                else document.getElementById('serverStatus').innerHTML =
                    '<div class="status-dot error"></div> Server Unreachable (Try Reloading)';
            };
        }

        function onServerMsg(msg) {
            switch (msg.type) {
                case 'discovery_list':
                    renderPeers(msg.peers);
                    break;
                case 'discovery_request':
                    handleDiscoveryRequest(msg.from, msg.nick);
                    break;
                case 'discovery_accepted':
                    finishDiscoveryConnect(msg.code, msg.initiator);
                    break;
                case 'traffic':
                    const badge = document.getElementById('trafficBadge');
                    const count = document.getElementById('trafficCount');
                    if (badge && count) {
                        badge.style.display = 'inline-flex';
                        count.textContent = msg.count;
                    }
                    break;
                case 'peer_joined':
                    connected = true;
                    // IMMEDIATELY exchange nicks via WebSocket and open chat
                    // This guarantees chat works even if WebRTC completely fails
                    relay({ kind: 'nick_exchange', nick: myNick });
                    // Start WebRTC in background as upgrade for file transfers
                    startWebRTC(isInitiator);
                    break;
                case 'relay':
                    onRelayData(msg.data);
                    break;
                case 'peer_left':
                    connected = false;
                    rtcConnected = false;
                    usingRTC = false;
                    enableChat(false);
                    sysMsg('Peer disconnected.');
                    document.getElementById('chatSubtext').innerHTML = 'üî¥ Session Terminated';
                    updateModeBadge('disconnected');
                    break;
                case 'error':
                    setJoinStatus(msg.msg || 'Unknown error', 'error');
                    break;
            }
        }

        function onRelayData(data) {
            if (!data) return;
            switch (data.kind) {
                // ‚îÄ‚îÄ Chat & identity ‚îÄ‚îÄ
                case 'nick_exchange':
                    peerNick = data.nick || 'Peer';
                    document.getElementById('chatSubtext').innerHTML =
                        `üü¢ Connected to <strong>${esc(peerNick)}</strong>`;
                    if (!chatVisible) {
                        chatVisible = true;
                        showChat();
                        enableChat(true);
                        sysMsg(`Session secured. ${esc(peerNick)} has joined.`);
                    } else {
                        sysMsg(`${esc(peerNick)} is in the session.`);
                    }
                    break;
                case 'chat':
                    addMsg(data.text, 'received', peerNick, data.msgId);
                    relay({ kind: 'read_receipt', msgId: data.msgId });
                    break;
                case 'read_receipt':
                    markSeen(data.msgId);
                    break;

                // ‚îÄ‚îÄ WebRTC Signaling ‚îÄ‚îÄ
                case 'rtc_offer': handleOffer(data.sdp); break;
                case 'rtc_answer': handleAnswer(data.sdp); break;
                case 'rtc_ice': handleIce(data.candidate); break;

                // ‚îÄ‚îÄ File handshake ‚îÄ‚îÄ
                case 'file-request':
                    // Receiver sees accept/decline dialog
                    showFileRequest(data);
                    break;
                case 'file-accepted':
                    // Sender can now start sending
                    startActualTransfer(data.fileId);
                    break;
                case 'file-declined':
                    // Sender notified of decline
                    onFileDeclined(data.fileId);
                    break;
                case 'file-cancelled':
                    // Either sender or receiver cancelled an active transfer
                    onFileCancelled(data.fileId, peerNick);
                    break;

                // ‚îÄ‚îÄ File chunks (WS relay fallback) ‚îÄ‚îÄ
                case 'file-meta':
                    incomingMeta = data;
                    incomingChunks = new Array(data.totalChunks);
                    incomingCount = 0;
                    appendFileProgress(data, peerNick, 'relay');
                    break;
                case 'file-chunk':
                    if (!incomingMeta) return;
                    incomingChunks[data.idx] = new Uint8Array(data.bytes);
                    incomingCount++;
                    updateSpeedAndProgress(incomingMeta.id, incomingCount, incomingMeta.totalChunks, incomingMeta.size);
                    if (incomingCount === incomingMeta.totalChunks) assembleFile();
                    break;
            }
        }

        function relay(data) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'relay', data }));
            }
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        //  WebRTC ‚Äî P2P Connection (background upgrade for files)
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        function startWebRTC(initiator) {
            isInitiator = initiator;
            updateModeBadge('relay'); // Start as relay, upgrade to P2P if WebRTC succeeds

            // Set a timeout ‚Äî if WebRTC doesn't connect in 10s, stay in relay mode
            if (rtcFallbackTimer) clearTimeout(rtcFallbackTimer);
            rtcFallbackTimer = setTimeout(() => {
                if (!usingRTC) {
                    updateModeBadge('relay');
                    console.log('WebRTC timed out ‚Äî staying in relay mode');
                }
            }, 10000);

            try {
                // We always provide ICE servers. If the devices are on the same LAN, WebRTC will naturally prioritize local 'host' candidates.
                // If local UDP is blocked by a firewall, it seamlessly falls back to STUN (Hairpinning) instead of failing.
                pc = new RTCPeerConnection({ iceServers: ICE_SERVERS });
            } catch (e) {
                console.warn('WebRTC not supported:', e);
                updateModeBadge('relay');
                return;
            }

            pc.onicecandidate = (e) => {
                if (e.candidate) {
                    relay({ kind: 'rtc_ice', candidate: e.candidate });
                }
            };

            // Function to check if the connection is truly local (host candidates)
            const checkLocalPath = async (pc) => {
                try {
                    const stats = await pc.getStats();
                    let isLocal = false;
                    stats.forEach(report => {
                        if (report.type === 'transport') {
                            const pair = stats.get(report.selectedCandidatePairId);
                            if (pair) {
                                const local = stats.get(pair.localCandidateId);
                                const remote = stats.get(pair.remoteCandidateId);
                                if (local && remote && local.candidateType === 'host' && remote.candidateType === 'host') {
                                    isLocal = true;
                                }
                            }
                        }
                    });
                    return isLocal;
                } catch (e) { return false; }
            };

            pc.onconnectionstatechange = () => {
                const state = pc.connectionState;
                console.log('RTC connection state:', state);
                if (state === 'connected') {
                    clearTimeout(rtcFallbackTimer);
                    rtcConnected = true;
                    usingRTC = true;

                    // Wait a moment for WebRTC to settle on the optimal candidate pair
                    setTimeout(async () => {
                        if (pc.connectionState !== 'connected') return;
                        const trulyLocal = await checkLocalPath(pc);
                        if (trulyLocal) {
                            CHUNK = CHUNK_SIZE_LAN;
                            updateModeBadge('lan_p2p');
                            sysMsg('‚ö° WebRTC LAN Direct active ‚Äî files transfer at full local Wi-Fi speed offline.');
                        } else {
                            CHUNK = CHUNK_SIZE_DEFAULT;
                            updateModeBadge('p2p');
                            sysMsg('üîí WebRTC P2P (Internet) active ‚Äî transfer routed via STUN Hairpinning. Set Windows Network to Private to allow offline LAN Direct speeds.');
                        }
                    }, 500);

                } else if (state === 'failed' || state === 'closed') {
                    rtcConnected = false;
                    usingRTC = false;
                    updateModeBadge('relay');
                    if (state === 'failed') sysMsg('‚ÑπÔ∏è P2P unavailable ‚Äî using relay for files.');
                }
            };

            pc.ondatachannel = (e) => {
                setupDataChannel(e.channel);
            };

            if (initiator) {
                const dc = pc.createDataChannel('files', { ordered: true });
                setupDataChannel(dc);
                pc.createOffer()
                    .then(offer => pc.setLocalDescription(offer))
                    .then(() => relay({ kind: 'rtc_offer', sdp: pc.localDescription }))
                    .catch(e => console.warn('RTC offer failed:', e));
            }
            // Joiner waits for offer via onRelayData ‚Üí handleOffer
        }

        function setupDataChannel(dc) {
            dataChannel = dc;
            dc.binaryType = 'arraybuffer';

            dc.onopen = () => {
                console.log('DataChannel open ‚Äî WebRTC P2P ready for files');
                // Note: nick exchange already done via WebSocket, no need to repeat
            };

            dc.onmessage = (e) => {
                onDataChannelMsg(e.data);
            };

            dc.onerror = (e) => {
                console.warn('DataChannel error:', e);
                usingRTC = false;
            };

            dc.onclose = () => {
                console.log('DataChannel closed');
                usingRTC = false;
            };
        }

        async function handleOffer(sdp) {
            if (!pc) startWebRTC(false);
            await pc.setRemoteDescription(new RTCSessionDescription(sdp));
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);
            relay({ kind: 'rtc_answer', sdp: answer });
        }

        async function handleAnswer(sdp) {
            await pc.setRemoteDescription(new RTCSessionDescription(sdp));
        }

        async function handleIce(candidate) {
            try {
                if (pc && candidate) await pc.addIceCandidate(new RTCIceCandidate(candidate));
            } catch (e) { console.warn('ICE error:', e); }
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        //  DataChannel Messages (P2P file transfer)
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        function onDataChannelMsg(data) {
            if (typeof data === 'string') {
                let msg;
                try { msg = JSON.parse(data); } catch { return; }
                if (msg.kind === 'file-meta') {
                    incomingMeta = msg;
                    incomingChunks = new Array(msg.totalChunks);
                    incomingCount = 0;
                    transferStats[msg.id] = { startTime: Date.now(), bytesTransferred: 0 };
                    appendFileProgress(msg, peerNick, 'p2p');
                }
            } else {
                // Binary chunk via DataChannel
                if (!incomingMeta) return;
                incomingChunks[incomingCount] = new Uint8Array(data);
                incomingCount++;
                updateSpeedAndProgress(incomingMeta.id, incomingCount, incomingMeta.totalChunks, incomingMeta.size);
                if (incomingCount === incomingMeta.totalChunks) assembleFile();
            }
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        //  ROOM & SETUP
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        function getNickname() {
            const nick = document.getElementById('nickInput').value.trim();
            if (!nick) {
                const inp = document.getElementById('nickInput');
                inp.style.borderColor = 'var(--brand-red)';
                inp.focus();
                setTimeout(() => inp.style.borderColor = 'var(--border)', 1200);
                return null;
            }
            return nick;
        }

        function createRoom() {
            myNick = getNickname();
            if (!myNick) return;

            finishCreateRoom();
        }

        function finishCreateRoom() {
            myCode = String(Math.floor(100000 + Math.random() * 900000));
            isInitiator = true;
            ws.send(JSON.stringify({ type: 'create', code: myCode }));
            document.getElementById('codeDisplay').textContent = myCode;
            document.getElementById('codeBox').classList.remove('hidden');
            document.getElementById('createBtn').disabled = true;
            document.getElementById('joinBtn').disabled = true;
            document.getElementById('nickInput').disabled = true;

            // Generate QR code with join URL
            generateJoinQR(myCode);

            // Start 10-minute countdown
            codeCreatedAt = Date.now();
            startCodeTimer();
        }

        function startCodeTimer() {
            if (timerInterval) clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                const elapsed = Date.now() - codeCreatedAt;
                const remaining = CODE_TTL - elapsed;
                if (remaining <= 0) {
                    clearInterval(timerInterval);
                    document.getElementById('codeTimer').textContent = '‚è± Expired';
                    document.getElementById('codeTimer').className = 'code-timer critical';
                    sysMsg('Room code expired. Reload to create a new room.');
                    return;
                }
                const mins = Math.floor(remaining / 60000);
                const secs = Math.floor((remaining % 60000) / 1000);
                const timerEl = document.getElementById('codeTimer');
                timerEl.textContent = `‚è± Expires in ${mins}:${String(secs).padStart(2, '0')}`;
                if (remaining < 60000) timerEl.className = 'code-timer critical';
                else if (remaining < 3 * 60000) timerEl.className = 'code-timer urgent';
                else timerEl.className = 'code-timer';
            }, 1000);
        }

        function toggleJoin() {
            const sec = document.getElementById('joinSection');
            sec.classList.toggle('hidden');
            if (!sec.classList.contains('hidden')) document.getElementById('joinInput').focus();
        }

        function joinRoom() {
            myNick = getNickname();
            if (!myNick) return;
            const code = document.getElementById('joinInput').value.trim();
            if (code.length !== 6) { setJoinStatus('Passcode must be 6 digits.', 'error'); return; }
            isInitiator = false;
            document.getElementById('nickInput').disabled = true;
            setJoinStatus('Connecting...', 'loading');

            ws.send(JSON.stringify({ type: 'join', code }));
        }

        function setJoinStatus(text, type) {
            const el = document.getElementById('joinStatus');
            el.innerHTML = `<div class="status-text" style="color:${type === 'error' ? 'var(--brand-red)' : 'var(--text-main)'}">
        <div class="status-dot ${type === 'error' ? 'error' : 'active'}"></div> ${text}</div>`;
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        //  CHAT UI
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        function showChat() {
            document.getElementById('setupScreen').classList.add('hidden');
            document.getElementById('chatScreen').style.display = 'flex';
            if (timerInterval) clearInterval(timerInterval);
        }

        function enableChat(on) {
            document.getElementById('msgInput').disabled = !on;
            document.getElementById('sendBtn').disabled = !on;
            document.getElementById('attachBtn').disabled = !on;
            document.getElementById('imgBtn').disabled = !on;
        }

        function updateModeBadge(mode) {
            const badge = document.getElementById('connectionModeBadge');
            if (mode === 'lan_p2p') {
                badge.className = 'mode-badge lan';
                badge.textContent = '‚ö° LAN Direct';
            } else if (mode === 'p2p' || mode === 'rtc') {
                badge.className = 'mode-badge';
                badge.textContent = 'üîí P2P (Internet)';
            } else if (mode === 'relay') {
                badge.className = 'mode-badge relay';
                badge.textContent = 'üîÅ Relay Mode';
            } else if (mode === 'connecting') {
                badge.className = 'mode-badge connecting';
                badge.textContent = '‚ö° Connecting...';
            } else {
                badge.className = 'mode-badge relay';
                badge.textContent = 'üî¥ Disconnected';
            }
        }

        function sendMessage() {
            const inp = document.getElementById('msgInput');
            const text = inp.value.trim();
            if (!text || !connected) return;

            const msgId = 'msg_' + (++msgIdCounter) + '_' + Date.now();
            relay({ kind: 'chat', text, msgId });
            const el = addMsg(text, 'sent', myNick, msgId);
            sentMsgMap[msgId] = el;
            inp.value = '';
            inp.style.height = 'auto'; // reset height
        }

        function onKey(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        }

        function addMsg(text, side, senderName, msgId) {
            const wrap = document.createElement('div');
            wrap.className = `msg-wrapper ${side}`;

            const now = new Date();
            const timeStr = now.getHours().toString().padStart(2, '0') + ':' + now.getMinutes().toString().padStart(2, '0');

            let html = '';
            if (senderName) html += `<div class="msg-nick">${esc(senderName)}</div>`;
            html += `<div class="msg">${esc(text)}</div>`;
            html += `<div class="msg-meta">
        <span class="msg-time">${timeStr}</span>
        ${side === 'sent' ? `<span class="read-tick" id="tick_${msgId}">‚úì</span>` : ''}
    </div>`;

            wrap.innerHTML = html;
            appendToChat(wrap);
            return wrap;
        }

        function markSeen(msgId) {
            const tick = document.getElementById('tick_' + msgId);
            if (tick) {
                tick.textContent = '‚úì‚úì';
                tick.classList.add('seen');
            }
        }

        function sysMsg(text) {
            const d = document.createElement('div');
            d.className = 'msg system';
            d.textContent = text;
            appendToChat(d);
        }

        function appendToChat(el) {
            const box = document.getElementById('chatMessages');
            box.appendChild(el);
            box.scrollTop = box.scrollHeight;
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        //  FILE TRANSFER
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        function pickFile() { document.getElementById('fileInput').click(); }

        function sendFile() {
            const inp = document.getElementById('fileInput');
            const file = inp.files[0];
            if (file) processFileToSend(file);
            inp.value = '';
        }

        async function processFileToSend(file) {
            if (!connected) return;

            const buf = await file.arrayBuffer();
            const totalChunks = Math.ceil(buf.byteLength / CHUNK);
            const fileId = 'f' + Date.now();
            const useRTC = usingRTC && dataChannel && dataChannel.readyState === 'open';

            // Store pending transfer ‚Äî actual send starts after receiver accepts
            pendingOutgoing[fileId] = { buf, totalChunks, file, useRTC };

            // Send file-request (metadata only, no data yet)
            const req = { kind: 'file-request', fileId, name: file.name, size: file.size, mime: file.type, totalChunks, useRTC };
            relay(req);

            // Show sender's "waiting" bubble
            const wrap = document.createElement('div');
            wrap.className = 'msg-wrapper sent';
            wrap.id = fileId;
            wrap.innerHTML = `
                <div class="msg-nick">${esc(myNick)}</div>
                <div class="msg file-msg">
                    <div class="file-msg-header">
                        <div class="file-icon">üìÑ</div>
                        <div class="file-info">
                            <div class="file-name">${esc(file.name)}</div>
                            <div class="file-meta" id="meta-${fileId}">${fmtSize(file.size)} ¬∑ ‚è≥ Waiting for acceptance...</div>
                            <div class="transfer-mode">${useRTC ? 'üîí P2P Direct' : 'üîÅ Via Relay'}</div>
                        </div>
                    </div>
                </div>`;
            appendToChat(wrap);
        }

        // Called when receiver accepts ‚Äî now actually send the data
        async function startActualTransfer(fileId) {
            const pending = pendingOutgoing[fileId];
            if (!pending) return;
            const { buf, totalChunks, file, useRTC } = pending;

            // Update sender bubble to show progress
            const metaEl = document.getElementById('meta-' + fileId);
            if (metaEl) metaEl.textContent = `${fmtSize(file.size)} ¬∑ Sending...`;

            // Add progress bar to sender bubble
            const msgDiv = document.querySelector(`#${fileId} .msg`);
            const isImage = msgDiv && msgDiv.classList.contains('image-msg');

            if (msgDiv) {
                if (isImage) {
                    msgDiv.insertAdjacentHTML('beforeend',
                        `<div class="progress-wrap" style="margin: 0 4px 4px 4px;"><div class="progress-bar" id="bar-${fileId}"></div></div>
                         <button class="btn-decline" style="margin: 0 4px 4px 4px; width: calc(100% - 8px); padding: 4px; font-size:11px;" onclick="cancelTransfer('${fileId}')">Cancel</button>`);
                } else {
                    msgDiv.insertAdjacentHTML('beforeend',
                        `<div class="progress-wrap"><div class="progress-bar" id="bar-${fileId}"></div></div>
                         <div class="progress-stats"><span id="pct-${fileId}">0%</span><span id="spd-${fileId}"></span></div>
                         <button class="btn-decline" style="margin-top:10px; width:100%;" onclick="cancelTransfer('${fileId}')">Cancel Transfer</button>`);
                }
            }

            transferStats[fileId] = { startTime: Date.now(), bytesTransferred: 0, aborted: false };

            if (useRTC && dataChannel && dataChannel.readyState === 'open') {
                // Send file-meta control message via DataChannel
                dataChannel.send(JSON.stringify({
                    kind: 'file-meta', id: fileId, name: file.name,
                    size: file.size, mime: file.type, totalChunks
                }));
                for (let i = 0; i < totalChunks; i++) {
                    if (transferStats[fileId]?.aborted) return; // Stop if cancelled
                    // Buffer threshold mapped to 4MB for high-speed LAN transfers
                    while (dataChannel.bufferedAmount > 4 * 1024 * 1024) await sleep(5);
                    const slice = buf.slice(i * CHUNK, (i + 1) * CHUNK);
                    dataChannel.send(slice);
                    transferStats[fileId].bytesTransferred += slice.byteLength;
                    updateSpeedAndProgress(fileId, i + 1, totalChunks, file.size);
                    if (i % 8 === 0) await sleep(0);
                }
            } else {
                // WS relay fallback
                relay({ kind: 'file-meta', id: fileId, name: file.name, size: file.size, mime: file.type, totalChunks });
                for (let i = 0; i < totalChunks; i++) {
                    if (transferStats[fileId]?.aborted) return; // Stop if cancelled
                    const slice = buf.slice(i * CHUNK, (i + 1) * CHUNK);
                    relay({ kind: 'file-chunk', idx: i, bytes: Array.from(new Uint8Array(slice)) });
                    transferStats[fileId].bytesTransferred += slice.byteLength;
                    updateSpeedAndProgress(fileId, i + 1, totalChunks, file.size);
                    if (i % 4 === 0) await sleep(0);
                }
            }

            // Remove cancel button & progress bars
            const cancelBtn = msgDiv?.querySelector('.btn-decline');
            if (cancelBtn) cancelBtn.remove();
            const pWrap = msgDiv?.querySelector('.progress-wrap');
            if (pWrap) pWrap.remove();
            const pStats = msgDiv?.querySelector('.progress-stats');
            if (pStats) pStats.remove();

            // Mark done
            if (!transferStats[fileId]?.aborted) {
                const metaEl2 = document.getElementById('meta-' + fileId);
                if (metaEl2) metaEl2.textContent = `${fmtSize(file.size)} ¬∑ ‚úì Sent`;

                // If it was an image, update sender preview (no download button needed for sender)
                const senderImg = document.querySelector(`#${fileId} .chat-image`);
                if (senderImg) {
                    senderImg.style.opacity = '1';
                    senderImg.style.filter = 'none';
                }
            }

            delete pendingOutgoing[fileId];
            delete transferStats[fileId];
        }

        function onFileDeclined(fileId) {
            const metaEl = document.getElementById('meta-' + fileId);
            if (metaEl) metaEl.textContent = fmtSize(pendingOutgoing[fileId]?.file?.size || 0) + ' ¬∑ ‚úó Declined';
            delete pendingOutgoing[fileId];
        }

        // Receiver sees this when a file-request arrives
        function showFileRequest(data) {
            const wrap = document.createElement('div');
            wrap.className = 'msg-wrapper received';
            wrap.id = data.fileId;
            wrap.innerHTML = `
                <div class="msg-nick">${esc(peerNick)}</div>
                <div class="msg file-msg">
                    <div class="file-msg-header">
                        <div class="file-icon">üìÑ</div>
                        <div class="file-info">
                            <div class="file-name">${esc(data.name)}</div>
                            <div class="file-meta" id="meta-${data.fileId}">${fmtSize(data.size)} ¬∑ ${data.useRTC ? 'üîí P2P' : 'üîÅ Relay'}</div>
                        </div>
                    </div>
                    <div class="file-actions">
                        <button class="btn-accept" onclick="acceptFile('${data.fileId}')">‚úì Accept</button>
                        <button class="btn-decline" onclick="declineFile('${data.fileId}')">‚úó Decline</button>
                    </div>
                </div>`;
            appendToChat(wrap);
        }

        function acceptFile(fileId) {
            relay({ kind: 'file-accepted', fileId });
            // Replace buttons with progress bar and cancel button
            const actionsEl = document.querySelector(`#${fileId} .file-actions`);
            if (actionsEl) {
                actionsEl.outerHTML = `
                    <div class="progress-wrap"><div class="progress-bar" id="bar-${fileId}"></div></div>
                    <div class="progress-stats"><span id="pct-${fileId}">0%</span><span id="spd-${fileId}"></span></div>
                    <button class="btn-decline" style="margin-top:10px; width:100%;" onclick="cancelTransfer('${fileId}')">Cancel Transfer</button>`;
            }
            const metaEl = document.getElementById('meta-' + fileId);
            if (metaEl) metaEl.textContent = metaEl.textContent.replace(/¬∑.*/, '¬∑ Receiving...');
            // Prepare incoming state
            // (actual data will arrive via file-meta + file-chunk or DataChannel)
        }

        function declineFile(fileId) {
            relay({ kind: 'file-declined', fileId });
            const wrap = document.getElementById(fileId);
            if (wrap) {
                const metaEl = document.getElementById('meta-' + fileId);
                if (metaEl) metaEl.textContent = metaEl.textContent.replace(/¬∑.*/, '¬∑ Declined');
                const actionsEl = wrap.querySelector('.file-actions');
                if (actionsEl) actionsEl.remove();
            }
        }

        function cancelTransfer(fileId) {
            // Notify peer
            relay({ kind: 'file-cancelled', fileId });
            onFileCancelled(fileId, 'You');
        }

        function onFileCancelled(fileId, who) {
            // Mark internal state as aborted
            if (transferStats[fileId]) transferStats[fileId].aborted = true;

            const wrap = document.getElementById(fileId);
            if (wrap) {
                const metaEl = document.getElementById('meta-' + fileId);
                if (metaEl) metaEl.textContent = metaEl.textContent.replace(/¬∑.*/, `¬∑ üõë Cancelled by ${who}`);

                // Remove progress elements
                const pWrap = wrap.querySelector('.progress-wrap');
                const pStats = wrap.querySelector('.progress-stats');
                const btn = wrap.querySelector('.btn-decline');
                if (pWrap) pWrap.remove();
                if (pStats) pStats.remove();
                if (btn) btn.remove();
            }

            // Clean up transfer states
            delete pendingOutgoing[fileId];
            delete transferStats[fileId];
            if (incomingMeta && incomingMeta.id === fileId) {
                incomingMeta = null;
                incomingChunks = [];
                incomingCount = 0;
            }
        }

        function assembleFile() {
            const meta = incomingMeta;
            const total = incomingChunks.reduce((s, c) => s + c.length, 0);
            const out = new Uint8Array(total);
            let off = 0;
            for (const c of incomingChunks) { out.set(c, off); off += c.length; }

            const blob = new Blob([out], { type: meta.mime });
            const url = URL.createObjectURL(blob);
            const isImage = meta.mime && meta.mime.startsWith('image/');

            const wrap = document.getElementById(meta.id);
            if (wrap) {
                const msgDiv = wrap.querySelector('.msg');
                // Remove progress stats and cancel button
                const statsEl = wrap.querySelector('.progress-stats');
                const cancelBtn = wrap.querySelector('.btn-decline');
                const progressWrap = wrap.querySelector('.progress-wrap');
                if (statsEl) statsEl.remove();
                if (cancelBtn) cancelBtn.remove();
                if (progressWrap) progressWrap.remove();

                if (isImage && msgDiv) {
                    // Replace file card content with inline image
                    msgDiv.innerHTML = `
                        <img class="chat-image" src="${url}" alt="${esc(meta.name)}" onclick="viewImage('${url}')">
                        <div style="display:flex; justify-content:flex-end; padding:2px 4px 2px 0;">
                            <a href="${url}" download="${esc(meta.name)}" style="color:var(--text-muted); font-size:11px; text-decoration:none; display:flex; gap:4px; align-items:center;">‚¨áÔ∏è Download ¬∑ ${fmtSize(meta.size)}</a>
                        </div>`;
                    msgDiv.classList.remove('file-msg');
                    msgDiv.classList.add('image-msg');
                    msgDiv.style.background = 'transparent';
                    msgDiv.style.padding = '4px';
                } else {
                    const metaEl = document.getElementById('meta-' + meta.id);
                    if (metaEl) metaEl.textContent = `${fmtSize(meta.size)} ¬∑ ‚¨á Tap to Download`;
                    if (msgDiv) {
                        msgDiv.style.cursor = 'pointer';
                        msgDiv.onclick = () => triggerDownload(url, meta.name);
                    }
                }
            }
            delete transferStats[meta.id];
            incomingMeta = null; incomingChunks = []; incomingCount = 0;
        }

        function appendFileProgress(meta, senderName, mode) {
            // Only called for WS relay chunks that arrive without accept flow
            // If the card already exists from file-request, simply update it
            if (document.getElementById(meta.id)) {
                transferStats[meta.id] = { startTime: Date.now(), bytesTransferred: 0 };
                return;
            }

            const wrap = document.createElement('div');
            wrap.className = 'msg-wrapper received';
            wrap.id = meta.id;
            wrap.innerHTML = `
                <div class="msg-nick">${esc(senderName)}</div>
                <div class="msg file-msg" style="flex-direction:column;align-items:stretch;">
                    <div style="display:flex;gap:12px;align-items:flex-start;">
                        <div class="file-icon">üìÑ</div>
                        <div class="file-info">
                            <div class="file-name">${esc(meta.name)}</div>
                            <div class="file-meta" id="meta-${meta.id}">${fmtSize(meta.size)} ¬∑ Receiving...</div>
                        </div>
                    </div>
                    <div class="progress-wrap"><div class="progress-bar" id="bar-${meta.id}"></div></div>
                    <div class="progress-stats"><span id="pct-${meta.id}">0%</span><span id="spd-${meta.id}"></span></div>
                </div>`;
            appendToChat(wrap);
            transferStats[meta.id] = { startTime: Date.now(), bytesTransferred: 0 };
        }

        function updateSpeedAndProgress(id, chunksReceived, totalChunks, totalSize) {
            const pct = Math.round((chunksReceived / totalChunks) * 100);
            const bar = document.getElementById('bar-' + id);
            if (bar) bar.style.width = pct + '%';
            const pctEl = document.getElementById('pct-' + id);
            if (pctEl) pctEl.textContent = pct + '%';

            const stats = transferStats[id];
            if (stats) {
                const elapsed = (Date.now() - stats.startTime) / 1000;
                const bytesReceived = (chunksReceived / totalChunks) * totalSize;
                const speed = elapsed > 0 ? bytesReceived / elapsed : 0;
                const spdEl = document.getElementById('spd-' + id);
                if (spdEl) spdEl.textContent = fmtSpeed(speed);
            }
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        //  HELPERS
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        function copyCode() {
            navigator.clipboard.writeText(myCode).then(() => sysMsg('Passcode copied to clipboard.'));
        }
        function disconnect() { if (pc) { pc.close(); pc = null; } if (ws) ws.close(); location.reload(); }
        function triggerDownload(url, name) { const a = document.createElement('a'); a.href = url; a.download = name; a.click(); }
        function fmtSize(b) {
            if (b < 1024) return b + ' B';
            if (b < 1048576) return (b / 1024).toFixed(1) + ' KB';
            if (b < 1073741824) return (b / 1048576).toFixed(1) + ' MB';
            return (b / 1073741824).toFixed(1) + ' GB';
        }
        function fmtSpeed(bps) {
            if (bps < 1024) return bps.toFixed(0) + ' B/s';
            if (bps < 1048576) return (bps / 1024).toFixed(1) + ' KB/s';
            return (bps / 1048576).toFixed(1) + ' MB/s';
        }
        function esc(s) { return String(s).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;'); }
        function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        //  QR CODE ‚Äî Generation & Scanning
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        function generateJoinQR(code) {
            const container = document.getElementById('qrContainer');
            if (!container) return;

            // Build join URL ‚Äî use current origin if available, fallback to vercel
            const base = location.origin && location.origin !== 'null'
                ? location.origin
                : 'https://chat-st99.onrender.com';
            const joinUrl = `${base}?join=${code}`;

            try {
                const qr = qrcode(0, 'M');
                qr.addData(joinUrl);
                qr.make();
                container.innerHTML = qr.createImgTag(5, 8) +
                    `<div class="qr-label">Scan to join \u00b7 or share the code above</div>`;
            } catch (e) {
                console.warn('QR generation failed:', e);
                container.innerHTML = '';
            }
        }

        function openQRScanner() {
            // Create overlay
            const overlay = document.createElement('div');
            overlay.className = 'qr-scanner-overlay';
            overlay.id = 'qrScannerOverlay';
            overlay.innerHTML = `
                <div class="scanner-title">\ud83d\udcf7 Scan Room QR Code</div>
                <video id="qrVideo" autoplay playsinline></video>
                <canvas id="qrCanvas" class="hidden"></canvas>
                <button class="btn-secondary" style="margin-top: 20px; width: 250px;" onclick="closeQRScanner()">Cancel</button>`;
            document.body.appendChild(overlay);

            const video = document.getElementById('qrVideo');
            const canvas = document.getElementById('qrCanvas');
            const ctx = canvas.getContext('2d');

            navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } })
                .then(stream => {
                    qrScannerStream = stream;
                    video.srcObject = stream;
                    video.play();

                    qrScanInterval = setInterval(() => {
                        if (video.readyState !== video.HAVE_ENOUGH_DATA) return;
                        canvas.width = video.videoWidth;
                        canvas.height = video.videoHeight;
                        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                        const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);

                        // Use jsQR to decode
                        if (typeof jsQR !== 'undefined') {
                            const result = jsQR(imgData.data, imgData.width, imgData.height);
                            if (result && result.data) {
                                handleQRResult(result.data);
                            }
                        }
                    }, 250);
                })
                .catch(err => {
                    console.warn('Camera access denied:', err);
                    closeQRScanner();
                    setJoinStatus('Camera access denied. Enter code manually.', 'error');
                });
        }

        function handleQRResult(data) {
            // Extract join code from URL like ?join=123456
            let code = null;
            try {
                const url = new URL(data);
                code = url.searchParams.get('join');
            } catch {
                // Maybe it's just a 6-digit code
                if (/^\d{6}$/.test(data.trim())) code = data.trim();
            }

            if (code && /^\d{6}$/.test(code)) {
                closeQRScanner();
                document.getElementById('joinInput').value = code;
                // Show join section if hidden
                const joinSec = document.getElementById('joinSection');
                if (joinSec.classList.contains('hidden')) joinSec.classList.remove('hidden');

                // Directly trigger join
                joinRoom();
            }
        }

        function closeQRScanner() {
            if (qrScanInterval) { clearInterval(qrScanInterval); qrScanInterval = null; }
            if (qrScannerStream) {
                qrScannerStream.getTracks().forEach(t => t.stop());
                qrScannerStream = null;
            }
            const overlay = document.getElementById('qrScannerOverlay');
            if (overlay) overlay.remove();
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        //  AUTO-DISCOVERY LOGIC
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        function getNicknameSilent() {
            return document.getElementById('nickInput').value.trim();
        }

        function onNickInput() {
            clearTimeout(nickTimeout);
            nickTimeout = setTimeout(() => {
                const nick = getNicknameSilent();
                if (nick && ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({
                        type: 'init_discovery',
                        peerId: myPeerId,
                        nick: nick,
                        os: getOS()
                    }));
                }
            }, 600);
        }

        function getOS() {
            if (/windows phone/i.test(navigator.userAgent)) return "Windows Phone";
            if (/android/i.test(navigator.userAgent)) return "Android";
            if (/iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream) return "iOS";
            if (/Mac/.test(navigator.userAgent)) return "Mac";
            if (/Win/.test(navigator.userAgent)) return "Windows";
            if (/Linux/.test(navigator.userAgent)) return "Linux";
            return "Unknown Device";
        }

        function renderPeers(peers) {
            const sec = document.getElementById('discoverySection');
            const list = document.getElementById('peerList');
            if (peers.length === 0) {
                sec.classList.add('hidden');
                list.innerHTML = '';
                return;
            }
            sec.classList.remove('hidden');
            list.innerHTML = peers.map(p => `
                <div class="peer-card" onclick="requestDiscoveryConnect('${p.id}')">
                    <div style="font-size:24px;">\ud83d\udcf1</div>
                    <div style="flex: 1;">
                        <div style="font-weight:600;">${esc(p.nick)}</div>
                        <div style="font-size:11px; color:var(--text-muted);">${esc(p.os)}</div>
                    </div>
                </div>
            `).join('');
        }

        function requestDiscoveryConnect(targetId) {
            if (!getNickname()) return;
            setJoinStatus('Sending connection request...', 'loading');
            ws.send(JSON.stringify({ type: 'request_connect', target: targetId }));
        }

        function handleDiscoveryRequest(fromId, nick) {
            const myNickSync = getNicknameSilent();
            if (!myNickSync) return;

            if (confirm(`User ${nick} wants to connect with you via local network. Accept?`)) {
                ws.send(JSON.stringify({ type: 'accept_connect', target: fromId }));
            } else {
                ws.send(JSON.stringify({ type: 'decline_connect', target: fromId }));
            }
        }

        function finishDiscoveryConnect(code, initiator) {
            viaDiscovery = true;
            myCode = code;
            isInitiator = initiator;

            document.getElementById('setupScreen').classList.add('hidden');
            document.getElementById('chatScreen').style.display = 'flex';
            if (timerInterval) clearInterval(timerInterval);

            connected = true;
            sysMsg('‚ö° Discovery handshake complete. Connecting WebRTC...');
            relay({ kind: 'nick_exchange', nick: getNicknameSilent() });

            startWebRTC(isInitiator);
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        //  IMAGE SENDING (with compression)
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        function pickImage() { document.getElementById('imageInput').click(); }

        function sendImageFile() {
            const inp = document.getElementById('imageInput');
            const file = inp.files[0];
            if (!file) return;
            inp.value = '';
            compressAndSendImage(file);
        }

        async function compressAndSendImage(file) {
            if (!connected) return;

            const MAX_DIM = 1200;
            const QUALITY = 0.7;

            try {
                // Read file as image
                const bitmap = await createImageBitmap(file);
                let w = bitmap.width;
                let h = bitmap.height;

                // Resize if needed
                if (w > MAX_DIM || h > MAX_DIM) {
                    if (w > h) { h = Math.round(h * MAX_DIM / w); w = MAX_DIM; }
                    else { w = Math.round(w * MAX_DIM / h); h = MAX_DIM; }
                }

                // Draw onto canvas and export as JPEG
                const canvas = document.createElement('canvas');
                canvas.width = w;
                canvas.height = h;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(bitmap, 0, 0, w, h);
                bitmap.close();

                const compressedBlob = await new Promise(resolve =>
                    canvas.toBlob(resolve, 'image/jpeg', QUALITY)
                );

                const originalSize = file.size;
                const compressedSize = compressedBlob.size;
                console.log(`Image compressed: ${fmtSize(originalSize)} ‚Üí ${fmtSize(compressedSize)} (${Math.round(compressedSize / originalSize * 100)}%)`);

                // Create a File from the blob for processFileToSend
                const compressedName = file.name.replace(/\.[^.]+$/, '') + '.jpg';
                const compressedFile = new File([compressedBlob], compressedName, { type: 'image/jpeg' });

                // Show sender's inline preview immediately
                const previewUrl = URL.createObjectURL(compressedBlob);
                sendImageWithPreview(compressedFile, previewUrl);

            } catch (e) {
                console.warn('Image compression failed, sending original:', e);
                processFileToSend(file);
            }
        }

        async function sendImageWithPreview(file, previewUrl) {
            if (!connected) return;

            const buf = await file.arrayBuffer();
            const totalChunks = Math.ceil(buf.byteLength / CHUNK);
            const fileId = 'f' + Date.now();
            const useRTC = usingRTC && dataChannel && dataChannel.readyState === 'open';

            // Store pending transfer
            pendingOutgoing[fileId] = { buf, totalChunks, file, useRTC };

            // Send file-request
            const req = { kind: 'file-request', fileId, name: file.name, size: file.size, mime: file.type, totalChunks, useRTC };
            relay(req);

            // Show sender's bubble with inline image preview
            const wrap = document.createElement('div');
            wrap.className = 'msg-wrapper sent';
            wrap.id = fileId;
            wrap.innerHTML = `
                <div class="msg-nick">${esc(myNick)}</div>
                <div class="msg image-msg" style="background:transparent; padding:4px;">
                    <img class="chat-image" src="${previewUrl}" alt="${esc(file.name)}" onclick="viewImage('${previewUrl}')" style="opacity:0.6; filter: grayscale(50%);">
                    <div class="file-meta" id="meta-${fileId}" style="font-size:11px; color:var(--text-muted); opacity:0.8; text-align:right; margin-top:2px;">${fmtSize(file.size)} ¬∑ ‚è≥ Waiting...</div>
                </div>`;
            appendToChat(wrap);
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        //  IMAGE VIEWER (full-screen overlay)
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        function viewImage(url) {
            const overlay = document.createElement('div');
            overlay.className = 'img-viewer-overlay';
            overlay.onclick = () => overlay.remove();
            overlay.innerHTML = `<img src="${url}" alt="Full size image">`;
            document.body.appendChild(overlay);
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        //  DEEP-LINK AUTO-JOIN
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        function checkDeepLink() {
            const params = new URLSearchParams(window.location.search);
            const joinCode = params.get('join');
            if (joinCode && /^\d{6}$/.test(joinCode)) {
                // Show join section and fill in the code
                const joinSec = document.getElementById('joinSection');
                if (joinSec.classList.contains('hidden')) joinSec.classList.remove('hidden');
                document.getElementById('joinInput').value = joinCode;
                // Focus nickname input
                document.getElementById('nickInput').focus();
                setJoinStatus('Room code loaded from QR link \u2014 enter nickname and click Connect.', 'loading');
            }
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        //  DRAG & DROP + INIT
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        function bindDragEvents() {
            const chatScreen = document.getElementById('chatScreen');

            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                chatScreen.addEventListener(eventName, e => {
                    e.preventDefault();
                    e.stopPropagation();
                }, false);
            });

            chatScreen.addEventListener('dragenter', () => chatScreen.classList.add('drag-active'), false);
            chatScreen.addEventListener('dragover', () => chatScreen.classList.add('drag-active'), false);
            chatScreen.addEventListener('dragleave', (e) => {
                if (!chatScreen.contains(e.relatedTarget)) {
                    chatScreen.classList.remove('drag-active');
                }
            }, false);

            chatScreen.addEventListener('drop', (e) => {
                chatScreen.classList.remove('drag-active');
                if (!connected) return;

                const file = e.dataTransfer.files[0];
                if (file) {
                    // Auto-detect images for inline display
                    if (file.type.startsWith('image/')) {
                        compressAndSendImage(file);
                    } else {
                        processFileToSend(file);
                    }
                }
            }, false);
        }

        window.addEventListener('load', () => {
            // Connect WebSocket
            connectWS();

            // Wait a moment for WS to configure, then check deep links and bind events
            setTimeout(() => {
                if (ws && ws.readyState === WebSocket.OPEN) onNickInput();
                else ws.addEventListener('open', () => onNickInput());
            }, 100);

            // Bind drag events
            bindDragEvents();

            // Check deep-link for auto-join
            checkDeepLink();

            // Register service worker for PWA
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.register('/sw.js')
                    .then(reg => console.log('SW registered:', reg.scope))
                    .catch(err => console.warn('SW registration failed:', err));
            }
        });

        // Clean up connections on page unload silently without annoying prompts
        window.addEventListener('unload', () => {
            if (pc) pc.close();
            if (ws) ws.close();
        });
    </script>
</body>

</html>