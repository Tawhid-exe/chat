<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DonkeyChat - Secure P2P</title>
    <meta name="description" content="Encrypted P2P chat and file transfer. No accounts, no traces, no server storage.">
    <style>
        :root {
            --bg-color: #09090b;
            --surface: #18181b;
            --surface-hover: #27272a;
            --border: #3f3f46;
            --text-main: #fafafa;
            --text-muted: #a1a1aa;
            --brand-red: #ef4444;
            --brand-red-hover: #dc2626;
            --red-glow: rgba(239, 68, 68, 0.15);
            --green: #22c55e;
            --radius-md: 12px;
            --radius-lg: 16px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Inter', 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-color);
            color: var(--text-main);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            line-height: 1.5;
        }

        .container {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: var(--radius-lg);
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5), 0 0 40px var(--red-glow);
            max-width: 540px;
            width: 100%;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* --- HEADER --- */
        .header {
            padding: 28px 32px 20px;
            text-align: center;
            border-bottom: 1px solid var(--border);
        }

        .header h1 {
            font-size: 22px;
            font-weight: 700;
            letter-spacing: -0.5px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .header p {
            color: var(--text-muted);
            font-size: 13px;
            margin-top: 6px;
        }

        /* --- SCREENS --- */
        #setupScreen {
            padding: 28px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        #chatScreen {
            display: none;
            padding: 0;
            height: 600px;
            flex-direction: column;
            position: relative;
        }

        /* --- INPUTS --- */
        .input-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .input-group label {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        input[type="text"] {
            width: 100%;
            background: var(--bg-color);
            border: 1px solid var(--border);
            color: var(--text-main);
            padding: 13px 16px;
            border-radius: var(--radius-md);
            font-size: 15px;
            transition: all 0.2s ease;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: var(--brand-red);
            box-shadow: 0 0 0 3px var(--red-glow);
        }

        input[type="text"]:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* --- BUTTONS --- */
        .btn-row {
            display: flex;
            gap: 12px;
        }

        button {
            padding: 13px 20px;
            border: none;
            border-radius: var(--radius-md);
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-primary {
            background: var(--brand-red);
            color: white;
            flex: 2;
        }

        .btn-primary:hover:not(:disabled) {
            background: var(--brand-red-hover);
        }

        .btn-secondary {
            background: var(--bg-color);
            color: var(--text-main);
            border: 1px solid var(--border);
            flex: 1;
        }

        .btn-secondary:hover:not(:disabled) {
            background: var(--surface-hover);
            border-color: #52525b;
        }

        /* --- CODE BOX --- */
        .code-box {
            background: var(--bg-color);
            border: 1px solid var(--border);
            border-radius: var(--radius-md);
            padding: 20px;
            text-align: center;
        }

        .code-digits {
            font-family: 'Courier New', monospace;
            font-size: 44px;
            font-weight: 700;
            letter-spacing: 8px;
            color: var(--brand-red);
            margin: 10px 0 6px;
            text-shadow: 0 0 20px rgba(239, 68, 68, 0.2);
        }

        .code-timer {
            font-size: 12px;
            color: var(--text-muted);
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }

        .code-timer.urgent {
            color: #f97316;
        }

        .code-timer.critical {
            color: var(--brand-red);
            animation: pulse 1s infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1
            }

            50% {
                opacity: 0.5
            }
        }

        .join-form {
            display: flex;
            gap: 8px;
        }

        .join-form input {
            text-align: center;
            letter-spacing: 4px;
            font-weight: 600;
            font-size: 18px;
        }

        /* --- STATUS --- */
        .info-box {
            background: rgba(239, 68, 68, 0.05);
            border: 1px solid rgba(239, 68, 68, 0.2);
            padding: 14px 16px;
            border-radius: var(--radius-md);
            font-size: 13px;
            color: #fca5a5;
            line-height: 1.6;
        }

        .info-box span {
            color: var(--brand-red);
            font-weight: bold;
        }

        /* WebRTC mode badge */
        .mode-badge {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            font-size: 11px;
            font-weight: 600;
            padding: 3px 8px;
            border-radius: 20px;
            background: rgba(34, 197, 94, 0.1);
            color: var(--green);
            border: 1px solid rgba(34, 197, 94, 0.25);
        }

        .mode-badge.relay {
            background: rgba(239, 68, 68, 0.1);
            color: #f87171;
            border-color: rgba(239, 68, 68, 0.25);
        }

        .mode-badge.connecting {
            background: rgba(251, 191, 36, 0.1);
            color: #fbbf24;
            border-color: rgba(251, 191, 36, 0.25);
        }

        .status-text {
            font-size: 13px;
            font-weight: 500;
            color: var(--text-muted);
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--text-muted);
            flex-shrink: 0;
        }

        .status-dot.active {
            background: var(--green);
            box-shadow: 0 0 10px rgba(34, 197, 94, 0.4);
        }

        .status-dot.error {
            background: var(--brand-red);
        }

        /* --- CHAT SCREEN --- */
        .chat-header {
            padding: 16px 20px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--surface);
            gap: 10px;
        }

        .chat-header-left {
            display: flex;
            flex-direction: column;
            gap: 4px;
            min-width: 0;
        }

        .chat-header-left h3 {
            font-size: 15px;
            font-weight: 600;
        }

        .chat-header-meta {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        .chat-header-meta p {
            font-size: 12px;
            color: var(--text-muted);
            white-space: nowrap;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 14px;
            background: var(--bg-color);
        }

        .chat-messages::-webkit-scrollbar {
            width: 5px;
        }

        .chat-messages::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 10px;
        }

        .msg-wrapper {
            display: flex;
            flex-direction: column;
            max-width: 80%;
        }

        .msg-wrapper.sent {
            align-self: flex-end;
            align-items: flex-end;
        }

        .msg-wrapper.received {
            align-self: flex-start;
            align-items: flex-start;
        }

        .msg-nick {
            font-size: 11px;
            font-weight: 600;
            color: var(--text-muted);
            margin-bottom: 3px;
            padding: 0 4px;
        }

        .msg {
            padding: 11px 15px;
            border-radius: 16px;
            font-size: 14px;
            line-height: 1.5;
            word-wrap: break-word;
            white-space: pre-wrap;
            position: relative;
        }

        .msg-wrapper.sent .msg {
            background: var(--brand-red);
            color: white;
            border-bottom-right-radius: 4px;
        }

        .msg-wrapper.received .msg {
            background: var(--surface);
            border: 1px solid var(--border);
            color: var(--text-main);
            border-bottom-left-radius: 4px;
        }

        /* Read receipt */
        .msg-meta {
            display: flex;
            align-items: center;
            gap: 4px;
            margin-top: 3px;
            padding: 0 4px;
        }

        .msg-time {
            font-size: 10px;
            color: var(--text-muted);
        }

        .read-tick {
            font-size: 12px;
            color: var(--text-muted);
            transition: color 0.3s;
            line-height: 1;
        }

        .read-tick.seen {
            color: #60a5fa;
        }

        .msg.system {
            align-self: center;
            background: transparent;
            color: var(--text-muted);
            font-size: 11px;
            font-weight: 500;
            padding: 6px 14px;
            border: 1px dashed var(--border);
            border-radius: 20px;
            max-width: 90%;
            text-align: center;
            margin: 4px 0;
        }

        .chat-input-area {
            padding: 16px 20px;
            background: var(--surface);
            border-top: 1px solid var(--border);
            display: flex;
            gap: 10px;
            align-items: flex-end;
        }

        .chat-input-area textarea {
            flex: 1;
            padding: 12px 16px;
            background: var(--bg-color);
            border: 1px solid var(--border);
            border-radius: 20px;
            color: white;
            font-size: 14px;
            transition: border-color 0.2s;
            resize: none;
            font-family: inherit;
            overflow-y: auto;
            max-height: 150px;
            min-height: 44px;
            box-sizing: border-box;
            line-height: 1.4;
        }

        .chat-input-area textarea:focus {
            outline: none;
            border-color: var(--brand-red);
        }

        .btn-icon {
            width: 42px;
            height: 42px;
            border-radius: 50%;
            background: var(--bg-color);
            border: 1px solid var(--border);
            color: var(--text-main);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            flex-shrink: 0;
            transition: 0.2s;
            font-size: 16px;
        }

        .btn-icon:hover:not(:disabled) {
            background: var(--surface-hover);
            color: var(--brand-red);
        }

        .btn-send {
            background: var(--brand-red);
            border: none;
            color: white;
        }

        .btn-send:hover:not(:disabled) {
            background: var(--brand-red-hover);
            color: white;
        }

        /* File UI */
        .file-msg {
            display: flex;
            align-items: flex-start;
            gap: 12px;
        }

        .file-icon {
            font-size: 26px;
            flex-shrink: 0;
            margin-top: 2px;
        }

        .file-info {
            flex: 1;
            min-width: 0;
        }

        .file-name {
            font-weight: 600;
            font-size: 13px;
            word-break: break-all;
            line-height: 1.3;
        }

        .file-meta {
            font-size: 11px;
            opacity: 0.75;
            margin-top: 3px;
        }

        /* Accept / Decline buttons */
        .file-actions {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }

        .btn-accept {
            flex: 1;
            padding: 8px 0;
            background: var(--green);
            color: #000;
            border: none;
            border-radius: 8px;
            font-size: 12px;
            font-weight: 700;
            cursor: pointer;
            transition: opacity 0.2s;
        }

        .btn-accept:hover {
            opacity: 0.85;
        }

        .btn-decline {
            flex: 1;
            padding: 8px 0;
            background: transparent;
            color: #f87171;
            border: 1px solid rgba(239, 68, 68, 0.4);
            border-radius: 8px;
            font-size: 12px;
            font-weight: 700;
            cursor: pointer;
            transition: background 0.2s;
        }

        .btn-decline:hover {
            background: rgba(239, 68, 68, 0.1);
        }

        /* Progress */
        .progress-wrap {
            margin-top: 10px;
            height: 4px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            width: 0%;
            transition: width 0.12s linear;
        }

        .msg-wrapper.sent .progress-bar {
            background: rgba(255, 255, 255, 0.75);
        }

        .msg-wrapper.received .progress-bar {
            background: var(--green);
        }

        .msg-wrapper.received .progress-wrap {
            background: rgba(0, 0, 0, 0.15);
        }

        .progress-stats {
            display: flex;
            justify-content: space-between;
            margin-top: 5px;
            font-size: 10px;
            opacity: 0.7;
        }

        /* Transfer mode label */
        .transfer-mode {
            font-size: 10px;
            opacity: 0.65;
            margin-top: 4px;
        }

        .hidden {
            display: none !important;
        }

        /* Drag Overlay */
        .drag-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(9, 9, 11, 0.85);
            backdrop-filter: blur(4px);
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            color: var(--brand-red);
            font-size: 20px;
            font-weight: 600;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
            border: 2px dashed var(--brand-red);
            border-radius: var(--radius-lg);
            margin: 10px;
        }

        #chatScreen.drag-active .drag-overlay {
            opacity: 1;
        }
    </style>
</head>

<body>

    <div class="container">
        <div class="header">
            <h1>ğŸ« DonkeyChat</h1>
            <p>Encrypted P2P network. Zero traces.</p>
        </div>

        <div id="setupScreen">
            <div class="status-text" id="serverStatus">
                <div class="status-dot"></div> Connecting to relay server...
            </div>

            <div class="input-group">
                <label>Nickname</label>
                <input type="text" id="nickInput" placeholder="Enter your display name..." maxlength="20">
            </div>

            <div class="btn-row">
                <button class="btn-primary" id="createBtn" onclick="createRoom()" disabled>Create Secure Room</button>
                <button class="btn-secondary" id="joinBtn" onclick="toggleJoin()" disabled>Join Room</button>
            </div>

            <div id="codeBox" class="code-box hidden">
                <div class="status-text">
                    <div class="status-dot active"></div> Room Active â€” Share code with peer
                </div>
                <div class="code-digits" id="codeDisplay">------</div>
                <div class="code-timer" id="codeTimer">â± Expires in 10:00</div>
                <button class="btn-secondary" style="width:100%;" onclick="copyCode()">ğŸ“‹ Copy Passcode</button>
            </div>

            <div id="joinSection" class="hidden">
                <div class="input-group">
                    <label>Enter Room Passcode</label>
                    <div class="join-form">
                        <input type="text" id="joinInput" placeholder="000000" maxlength="6" inputmode="numeric"
                            oninput="this.value=this.value.replace(/\D/g,'')">
                        <button class="btn-primary" style="flex:0 0 auto;" onclick="joinRoom()">Connect</button>
                    </div>
                </div>
                <div id="joinStatus" style="margin-top:10px;"></div>
            </div>

            <div class="info-box">
                <span>How it works:</span> Chat uses your relay server. Files transfer <strong>directly P2P via
                    WebRTC</strong> â€” your server never sees file data. If WebRTC fails, files fall back through the
                relay. Max file size: <strong>4GB+</strong> (WebRTC) / 100MB (relay fallback). Room codes expire in
                <strong>10 minutes</strong>.
            </div>
        </div>

        <div id="chatScreen">
            <div class="chat-header">
                <div class="chat-header-left">
                    <h3>Secure Session</h3>
                    <div class="chat-header-meta">
                        <p id="chatSubtext">ğŸŸ¢ Connected</p>
                        <span id="connectionModeBadge" class="mode-badge connecting">âš¡ Connecting...</span>
                    </div>
                </div>
                <button class="btn-secondary" style="padding:8px 12px;font-size:12px;flex:none;"
                    onclick="disconnect()">End Session</button>
            </div>

            <div class="chat-messages" id="chatMessages"></div>

            <div class="chat-input-area">
                <button class="btn-icon" id="attachBtn" onclick="pickFile()" disabled title="Send File">ğŸ“</button>
                <textarea id="msgInput" placeholder="Type a secure message..." onkeydown="onKey(event)"
                    oninput="this.style.height='auto';this.style.height=(this.scrollHeight)+'px';" rows="1"
                    disabled></textarea>
                <button class="btn-icon btn-send" id="sendBtn" onclick="sendMessage()" disabled title="Send">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                        stroke-linecap="round" stroke-linejoin="round">
                        <line x1="22" y1="2" x2="11" y2="13"></line>
                        <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
                    </svg>
                </button>
            </div>
            <input type="file" id="fileInput" class="hidden" onchange="sendFile()">
            <div class="drag-overlay">
                <div>ğŸ“ Drop File to Send</div>
            </div>
        </div>
    </div>

    <script>
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  CONFIG
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const WS_URL = 'wss://chat-st99.onrender.com';
        const CODE_TTL = 10 * 60 * 1000; // 10 minutes

        // ICE servers: multiple STUN + TURN fallbacks
        // Priority: Google STUN (free, unlimited) â†’ OpenRelay TURN â†’ ExpressTURN â†’ Cloudflare TURN
        const ICE_SERVERS = [
            // Google STUN â€” always free, unlimited
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun1.l.google.com:19302' },
            { urls: 'stun:stun2.l.google.com:19302' },
            { urls: 'stun:stun3.l.google.com:19302' },
            { urls: 'stun:stun4.l.google.com:19302' },
            // OpenRelay (Metered) â€” 20GB/month free TURN, ports 80/443, SSL bypass
            {
                urls: 'stun:openrelay.metered.ca:80'
            },
            {
                urls: 'turn:openrelay.metered.ca:80',
                username: 'openrelayproject',
                credential: 'openrelayproject'
            },
            {
                urls: 'turn:openrelay.metered.ca:443',
                username: 'openrelayproject',
                credential: 'openrelayproject'
            },
            {
                urls: 'turn:openrelay.metered.ca:443?transport=tcp',
                username: 'openrelayproject',
                credential: 'openrelayproject'
            },
            // ExpressTURN â€” 1000GB/month free
            {
                urls: 'stun:stun.expressturn.com:3478'
            },
            {
                urls: 'turn:stun.expressturn.com:3478',
                username: 'efUN6XXXXXXXXXXX',   // placeholder â€” works without for STUN
                credential: 'expressturn'
            },
            // Cloudflare STUN (public)
            { urls: 'stun:stun.cloudflare.com:3478' },
            // Additional public STUN servers
            { urls: 'stun:stun.stunprotocol.org:3478' },
            { urls: 'stun:stun.voip.blackberry.com:3478' },
            { urls: 'stun:stun.nextcloud.com:443' },
        ];

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  STATE
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        let ws = null;
        let myCode = '';
        let connected = false;
        let myNick = '';
        let peerNick = 'Peer';
        let codeCreatedAt = null;
        let timerInterval = null;
        let chatVisible = false;  // tracks if chat screen is already shown

        // WebRTC state
        let pc = null;           // RTCPeerConnection
        let dataChannel = null;  // RTCDataChannel for files
        let isInitiator = false; // true = room creator
        let rtcConnected = false;
        let usingRTC = false;    // true = WebRTC data channel active
        let rtcFallbackTimer = null; // timer to detect RTC failure

        // File transfer state
        let incomingMeta = null;
        let incomingChunks = [];
        let incomingCount = 0;
        // Pending outgoing transfers waiting for receiver acceptance
        // fileId â†’ { buf, meta, useRTC }
        let pendingOutgoing = {};
        // Speed tracking per transfer
        // fileId â†’ { startTime, bytesTransferred }
        let transferStats = {};

        // Read receipts: msgId â†’ DOM element
        let sentMsgMap = {};
        let msgIdCounter = 0;

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  WEBSOCKET â€” Signaling + Chat + Fallback
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function connectWS() {
            ws = new WebSocket(WS_URL);

            ws.onopen = () => {
                const stat = document.getElementById('serverStatus');
                stat.innerHTML = '<div class="status-dot active"></div> Relay Server Online';
                document.getElementById('createBtn').disabled = false;
                document.getElementById('joinBtn').disabled = false;
            };

            ws.onmessage = (e) => {
                let msg;
                try { msg = JSON.parse(e.data); } catch { return; }
                onServerMsg(msg);
            };

            ws.onclose = () => {
                if (connected) sysMsg('Connection to relay lost.');
                else document.getElementById('serverStatus').innerHTML =
                    '<div class="status-dot error"></div> Server Unreachable (Try Reloading)';
            };
        }

        function onServerMsg(msg) {
            switch (msg.type) {
                case 'peer_joined':
                    connected = true;
                    // IMMEDIATELY exchange nicks via WebSocket and open chat
                    // This guarantees chat works even if WebRTC completely fails
                    relay({ kind: 'nick_exchange', nick: myNick });
                    // Start WebRTC in background as upgrade for file transfers
                    startWebRTC(isInitiator);
                    break;
                case 'relay':
                    onRelayData(msg.data);
                    break;
                case 'peer_left':
                    connected = false;
                    rtcConnected = false;
                    usingRTC = false;
                    enableChat(false);
                    sysMsg('Peer disconnected.');
                    document.getElementById('chatSubtext').innerHTML = 'ğŸ”´ Session Terminated';
                    updateModeBadge('disconnected');
                    break;
                case 'error':
                    setJoinStatus(msg.msg || 'Unknown error', 'error');
                    break;
            }
        }

        function onRelayData(data) {
            if (!data) return;
            switch (data.kind) {
                // â”€â”€ Chat & identity â”€â”€
                case 'nick_exchange':
                    peerNick = data.nick || 'Peer';
                    document.getElementById('chatSubtext').innerHTML =
                        `ğŸŸ¢ Connected to <strong>${esc(peerNick)}</strong>`;
                    if (!chatVisible) {
                        chatVisible = true;
                        showChat();
                        enableChat(true);
                        sysMsg(`Session secured. ${esc(peerNick)} has joined.`);
                    } else {
                        sysMsg(`${esc(peerNick)} is in the session.`);
                    }
                    break;
                case 'chat':
                    addMsg(data.text, 'received', peerNick, data.msgId);
                    relay({ kind: 'read_receipt', msgId: data.msgId });
                    break;
                case 'read_receipt':
                    markSeen(data.msgId);
                    break;

                // â”€â”€ WebRTC Signaling â”€â”€
                case 'rtc_offer': handleOffer(data.sdp); break;
                case 'rtc_answer': handleAnswer(data.sdp); break;
                case 'rtc_ice': handleIce(data.candidate); break;

                // â”€â”€ File handshake â”€â”€
                case 'file-request':
                    // Receiver sees accept/decline dialog
                    showFileRequest(data);
                    break;
                case 'file-accepted':
                    // Sender can now start sending
                    startActualTransfer(data.fileId);
                    break;
                case 'file-declined':
                    // Sender notified of decline
                    onFileDeclined(data.fileId);
                    break;

                // â”€â”€ File chunks (WS relay fallback) â”€â”€
                case 'file-meta':
                    incomingMeta = data;
                    incomingChunks = new Array(data.totalChunks);
                    incomingCount = 0;
                    appendFileProgress(data, peerNick, 'relay');
                    break;
                case 'file-chunk':
                    if (!incomingMeta) return;
                    incomingChunks[data.idx] = new Uint8Array(data.bytes);
                    incomingCount++;
                    updateSpeedAndProgress(incomingMeta.id, incomingCount, incomingMeta.totalChunks, incomingMeta.size);
                    if (incomingCount === incomingMeta.totalChunks) assembleFile();
                    break;
            }
        }

        function relay(data) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'relay', data }));
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  WebRTC â€” P2P Connection (background upgrade for files)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function startWebRTC(initiator) {
            isInitiator = initiator;
            updateModeBadge('relay'); // Start as relay, upgrade to P2P if WebRTC succeeds

            // Set a timeout â€” if WebRTC doesn't connect in 10s, stay in relay mode
            if (rtcFallbackTimer) clearTimeout(rtcFallbackTimer);
            rtcFallbackTimer = setTimeout(() => {
                if (!usingRTC) {
                    updateModeBadge('relay');
                    console.log('WebRTC timed out â€” staying in relay mode');
                }
            }, 10000);

            try {
                pc = new RTCPeerConnection({ iceServers: ICE_SERVERS });
            } catch (e) {
                console.warn('WebRTC not supported:', e);
                updateModeBadge('relay');
                return;
            }

            pc.onicecandidate = (e) => {
                if (e.candidate) {
                    relay({ kind: 'rtc_ice', candidate: e.candidate });
                }
            };

            pc.onconnectionstatechange = () => {
                const state = pc.connectionState;
                console.log('RTC connection state:', state);
                if (state === 'connected') {
                    clearTimeout(rtcFallbackTimer);
                    rtcConnected = true;
                    usingRTC = true;
                    updateModeBadge('p2p');
                    sysMsg('ğŸ”’ WebRTC P2P active â€” files now transfer directly (faster & private).');
                } else if (state === 'failed' || state === 'closed') {
                    rtcConnected = false;
                    usingRTC = false;
                    updateModeBadge('relay');
                    if (state === 'failed') sysMsg('â„¹ï¸ P2P unavailable â€” using relay for files.');
                }
            };

            pc.ondatachannel = (e) => {
                setupDataChannel(e.channel);
            };

            if (initiator) {
                const dc = pc.createDataChannel('files', { ordered: true });
                setupDataChannel(dc);
                pc.createOffer()
                    .then(offer => pc.setLocalDescription(offer))
                    .then(() => relay({ kind: 'rtc_offer', sdp: pc.localDescription }))
                    .catch(e => console.warn('RTC offer failed:', e));
            }
            // Joiner waits for offer via onRelayData â†’ handleOffer
        }

        function setupDataChannel(dc) {
            dataChannel = dc;
            dc.binaryType = 'arraybuffer';

            dc.onopen = () => {
                console.log('DataChannel open â€” WebRTC P2P ready for files');
                // Note: nick exchange already done via WebSocket, no need to repeat
            };

            dc.onmessage = (e) => {
                onDataChannelMsg(e.data);
            };

            dc.onerror = (e) => {
                console.warn('DataChannel error:', e);
                usingRTC = false;
            };

            dc.onclose = () => {
                console.log('DataChannel closed');
                usingRTC = false;
            };
        }

        async function handleOffer(sdp) {
            if (!pc) startWebRTC(false);
            await pc.setRemoteDescription(new RTCSessionDescription(sdp));
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);
            relay({ kind: 'rtc_answer', sdp: answer });
        }

        async function handleAnswer(sdp) {
            await pc.setRemoteDescription(new RTCSessionDescription(sdp));
        }

        async function handleIce(candidate) {
            try {
                if (pc && candidate) await pc.addIceCandidate(new RTCIceCandidate(candidate));
            } catch (e) { console.warn('ICE error:', e); }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  DataChannel Messages (P2P file transfer)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function onDataChannelMsg(data) {
            if (typeof data === 'string') {
                let msg;
                try { msg = JSON.parse(data); } catch { return; }
                if (msg.kind === 'file-meta') {
                    incomingMeta = msg;
                    incomingChunks = new Array(msg.totalChunks);
                    incomingCount = 0;
                    transferStats[msg.id] = { startTime: Date.now(), bytesTransferred: 0 };
                    appendFileProgress(msg, peerNick, 'p2p');
                }
            } else {
                // Binary chunk via DataChannel
                if (!incomingMeta) return;
                incomingChunks[incomingCount] = new Uint8Array(data);
                incomingCount++;
                updateSpeedAndProgress(incomingMeta.id, incomingCount, incomingMeta.totalChunks, incomingMeta.size);
                if (incomingCount === incomingMeta.totalChunks) assembleFile();
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  ROOM & SETUP
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function getNickname() {
            const nick = document.getElementById('nickInput').value.trim();
            if (!nick) {
                const inp = document.getElementById('nickInput');
                inp.style.borderColor = 'var(--brand-red)';
                inp.focus();
                setTimeout(() => inp.style.borderColor = 'var(--border)', 1200);
                return null;
            }
            return nick;
        }

        function createRoom() {
            myNick = getNickname();
            if (!myNick) return;

            myCode = String(Math.floor(100000 + Math.random() * 900000));
            isInitiator = true;
            ws.send(JSON.stringify({ type: 'create', code: myCode }));
            document.getElementById('codeDisplay').textContent = myCode;
            document.getElementById('codeBox').classList.remove('hidden');
            document.getElementById('createBtn').disabled = true;
            document.getElementById('joinBtn').disabled = true;
            document.getElementById('nickInput').disabled = true;

            // Start 10-minute countdown
            codeCreatedAt = Date.now();
            startCodeTimer();
        }

        function startCodeTimer() {
            if (timerInterval) clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                const elapsed = Date.now() - codeCreatedAt;
                const remaining = CODE_TTL - elapsed;
                if (remaining <= 0) {
                    clearInterval(timerInterval);
                    document.getElementById('codeTimer').textContent = 'â± Expired';
                    document.getElementById('codeTimer').className = 'code-timer critical';
                    sysMsg('Room code expired. Reload to create a new room.');
                    return;
                }
                const mins = Math.floor(remaining / 60000);
                const secs = Math.floor((remaining % 60000) / 1000);
                const timerEl = document.getElementById('codeTimer');
                timerEl.textContent = `â± Expires in ${mins}:${String(secs).padStart(2, '0')}`;
                if (remaining < 60000) timerEl.className = 'code-timer critical';
                else if (remaining < 3 * 60000) timerEl.className = 'code-timer urgent';
                else timerEl.className = 'code-timer';
            }, 1000);
        }

        function toggleJoin() {
            const sec = document.getElementById('joinSection');
            sec.classList.toggle('hidden');
            if (!sec.classList.contains('hidden')) document.getElementById('joinInput').focus();
        }

        function joinRoom() {
            myNick = getNickname();
            if (!myNick) return;
            const code = document.getElementById('joinInput').value.trim();
            if (code.length !== 6) { setJoinStatus('Passcode must be 6 digits.', 'error'); return; }
            isInitiator = false;
            document.getElementById('nickInput').disabled = true;
            setJoinStatus('Connecting...', 'loading');
            ws.send(JSON.stringify({ type: 'join', code }));
        }

        function setJoinStatus(text, type) {
            const el = document.getElementById('joinStatus');
            el.innerHTML = `<div class="status-text" style="color:${type === 'error' ? 'var(--brand-red)' : 'var(--text-main)'}">
        <div class="status-dot ${type === 'error' ? 'error' : 'active'}"></div> ${text}</div>`;
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  CHAT UI
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function showChat() {
            document.getElementById('setupScreen').classList.add('hidden');
            document.getElementById('chatScreen').style.display = 'flex';
            if (timerInterval) clearInterval(timerInterval);
        }

        function enableChat(on) {
            document.getElementById('msgInput').disabled = !on;
            document.getElementById('sendBtn').disabled = !on;
            document.getElementById('attachBtn').disabled = !on;
        }

        function updateModeBadge(mode) {
            const badge = document.getElementById('connectionModeBadge');
            if (mode === 'p2p') {
                badge.className = 'mode-badge';
                badge.textContent = 'ğŸ”’ P2P Direct';
            } else if (mode === 'relay') {
                badge.className = 'mode-badge relay';
                badge.textContent = 'ğŸ” Relay Mode';
            } else if (mode === 'connecting') {
                badge.className = 'mode-badge connecting';
                badge.textContent = 'âš¡ Connecting...';
            } else {
                badge.className = 'mode-badge relay';
                badge.textContent = 'ğŸ”´ Disconnected';
            }
        }

        function sendMessage() {
            const inp = document.getElementById('msgInput');
            const text = inp.value.trim();
            if (!text || !connected) return;

            const msgId = 'msg_' + (++msgIdCounter) + '_' + Date.now();
            relay({ kind: 'chat', text, msgId });
            const el = addMsg(text, 'sent', myNick, msgId);
            sentMsgMap[msgId] = el;
            inp.value = '';
            inp.style.height = 'auto'; // reset height
        }

        function onKey(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        }

        function addMsg(text, side, senderName, msgId) {
            const wrap = document.createElement('div');
            wrap.className = `msg-wrapper ${side}`;

            const now = new Date();
            const timeStr = now.getHours().toString().padStart(2, '0') + ':' + now.getMinutes().toString().padStart(2, '0');

            let html = '';
            if (senderName) html += `<div class="msg-nick">${esc(senderName)}</div>`;
            html += `<div class="msg">${esc(text)}</div>`;
            html += `<div class="msg-meta">
        <span class="msg-time">${timeStr}</span>
        ${side === 'sent' ? `<span class="read-tick" id="tick_${msgId}">âœ“</span>` : ''}
    </div>`;

            wrap.innerHTML = html;
            appendToChat(wrap);
            return wrap;
        }

        function markSeen(msgId) {
            const tick = document.getElementById('tick_' + msgId);
            if (tick) {
                tick.textContent = 'âœ“âœ“';
                tick.classList.add('seen');
            }
        }

        function sysMsg(text) {
            const d = document.createElement('div');
            d.className = 'msg system';
            d.textContent = text;
            appendToChat(d);
        }

        function appendToChat(el) {
            const box = document.getElementById('chatMessages');
            box.appendChild(el);
            box.scrollTop = box.scrollHeight;
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  FILE TRANSFER
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function pickFile() { document.getElementById('fileInput').click(); }

        function sendFile() {
            const inp = document.getElementById('fileInput');
            const file = inp.files[0];
            if (file) processFileToSend(file);
            inp.value = '';
        }

        async function processFileToSend(file) {
            if (!connected) return;

            const CHUNK = 16 * 1024;
            const buf = await file.arrayBuffer();
            const totalChunks = Math.ceil(buf.byteLength / CHUNK);
            const fileId = 'f' + Date.now();
            const useRTC = usingRTC && dataChannel && dataChannel.readyState === 'open';

            // Store pending transfer â€” actual send starts after receiver accepts
            pendingOutgoing[fileId] = { buf, totalChunks, file, useRTC };

            // Send file-request (metadata only, no data yet)
            const req = { kind: 'file-request', fileId, name: file.name, size: file.size, mime: file.type, totalChunks, useRTC };
            relay(req);

            // Show sender's "waiting" bubble
            const wrap = document.createElement('div');
            wrap.className = 'msg-wrapper sent';
            wrap.id = fileId;
            wrap.innerHTML = `
                <div class="msg-nick">${esc(myNick)}</div>
                <div class="msg file-msg">
                    <div class="file-icon">ğŸ“„</div>
                    <div class="file-info">
                        <div class="file-name">${esc(file.name)}</div>
                        <div class="file-meta" id="meta-${fileId}">${fmtSize(file.size)} Â· â³ Waiting for acceptance...</div>
                        <div class="transfer-mode">${useRTC ? 'ğŸ”’ P2P Direct' : 'ğŸ” Via Relay'}</div>
                    </div>
                </div>`;
            appendToChat(wrap);
        }

        // Called when receiver accepts â€” now actually send the data
        async function startActualTransfer(fileId) {
            const pending = pendingOutgoing[fileId];
            if (!pending) return;
            const { buf, totalChunks, file, useRTC } = pending;
            const CHUNK = 16 * 1024;

            // Update sender bubble to show progress
            const metaEl = document.getElementById('meta-' + fileId);
            if (metaEl) metaEl.textContent = `${fmtSize(file.size)} Â· Sending...`;

            // Add progress bar to sender bubble
            const msgDiv = document.querySelector(`#${fileId} .msg`);
            if (msgDiv) {
                msgDiv.insertAdjacentHTML('beforeend',
                    `<div class="progress-wrap"><div class="progress-bar" id="bar-${fileId}"></div></div>
                     <div class="progress-stats"><span id="pct-${fileId}">0%</span><span id="spd-${fileId}"></span></div>`);
            }

            transferStats[fileId] = { startTime: Date.now(), bytesTransferred: 0 };

            if (useRTC && dataChannel && dataChannel.readyState === 'open') {
                // Send file-meta control message via DataChannel
                dataChannel.send(JSON.stringify({
                    kind: 'file-meta', id: fileId, name: file.name,
                    size: file.size, mime: file.type, totalChunks
                }));
                for (let i = 0; i < totalChunks; i++) {
                    while (dataChannel.bufferedAmount > 256 * 1024) await sleep(10);
                    const slice = buf.slice(i * CHUNK, (i + 1) * CHUNK);
                    dataChannel.send(slice);
                    transferStats[fileId].bytesTransferred += slice.byteLength;
                    updateSpeedAndProgress(fileId, i + 1, totalChunks, file.size);
                    if (i % 8 === 0) await sleep(0);
                }
            } else {
                // WS relay fallback
                relay({ kind: 'file-meta', id: fileId, name: file.name, size: file.size, mime: file.type, totalChunks });
                for (let i = 0; i < totalChunks; i++) {
                    const slice = buf.slice(i * CHUNK, (i + 1) * CHUNK);
                    relay({ kind: 'file-chunk', idx: i, bytes: Array.from(new Uint8Array(slice)) });
                    transferStats[fileId].bytesTransferred += slice.byteLength;
                    updateSpeedAndProgress(fileId, i + 1, totalChunks, file.size);
                    if (i % 4 === 0) await sleep(0);
                }
            }

            // Mark done
            const metaEl2 = document.getElementById('meta-' + fileId);
            if (metaEl2) metaEl2.textContent = `${fmtSize(file.size)} Â· âœ“ Sent`;
            delete pendingOutgoing[fileId];
            delete transferStats[fileId];
        }

        function onFileDeclined(fileId) {
            const metaEl = document.getElementById('meta-' + fileId);
            if (metaEl) metaEl.textContent = fmtSize(pendingOutgoing[fileId]?.file?.size || 0) + ' Â· âœ— Declined';
            delete pendingOutgoing[fileId];
        }

        // Receiver sees this when a file-request arrives
        function showFileRequest(data) {
            const wrap = document.createElement('div');
            wrap.className = 'msg-wrapper received';
            wrap.id = data.fileId;
            wrap.innerHTML = `
                <div class="msg-nick">${esc(peerNick)}</div>
                <div class="msg file-msg" style="flex-direction:column;align-items:stretch;">
                    <div style="display:flex;gap:12px;align-items:flex-start;">
                        <div class="file-icon">ğŸ“„</div>
                        <div class="file-info">
                            <div class="file-name">${esc(data.name)}</div>
                            <div class="file-meta" id="meta-${data.fileId}">${fmtSize(data.size)} Â· ${data.useRTC ? 'ğŸ”’ P2P' : 'ğŸ” Relay'}</div>
                        </div>
                    </div>
                    <div class="file-actions">
                        <button class="btn-accept" onclick="acceptFile('${data.fileId}')">âœ“ Accept</button>
                        <button class="btn-decline" onclick="declineFile('${data.fileId}')">âœ— Decline</button>
                    </div>
                </div>`;
            appendToChat(wrap);
        }

        function acceptFile(fileId) {
            relay({ kind: 'file-accepted', fileId });
            // Replace buttons with progress bar
            const actionsEl = document.querySelector(`#${fileId} .file-actions`);
            if (actionsEl) {
                actionsEl.outerHTML = `
                    <div class="progress-wrap"><div class="progress-bar" id="bar-${fileId}"></div></div>
                    <div class="progress-stats"><span id="pct-${fileId}">0%</span><span id="spd-${fileId}"></span></div>`;
            }
            const metaEl = document.getElementById('meta-' + fileId);
            if (metaEl) metaEl.textContent = metaEl.textContent.replace(/Â·.*/, 'Â· Receiving...');
            // Prepare incoming state
            // (actual data will arrive via file-meta + file-chunk or DataChannel)
        }

        function declineFile(fileId) {
            relay({ kind: 'file-declined', fileId });
            const wrap = document.getElementById(fileId);
            if (wrap) {
                const metaEl = document.getElementById('meta-' + fileId);
                if (metaEl) metaEl.textContent = metaEl.textContent.replace(/Â·.*/, 'Â· Declined');
                const actionsEl = wrap.querySelector('.file-actions');
                if (actionsEl) actionsEl.remove();
            }
        }

        function assembleFile() {
            const meta = incomingMeta;
            const total = incomingChunks.reduce((s, c) => s + c.length, 0);
            const out = new Uint8Array(total);
            let off = 0;
            for (const c of incomingChunks) { out.set(c, off); off += c.length; }

            const blob = new Blob([out], { type: meta.mime });
            const url = URL.createObjectURL(blob);

            const wrap = document.getElementById(meta.id);
            if (wrap) {
                const metaEl = document.getElementById('meta-' + meta.id);
                if (metaEl) metaEl.textContent = `${fmtSize(meta.size)} Â· â¬‡ Tap to Download`;
                const msgDiv = wrap.querySelector('.msg');
                if (msgDiv) {
                    msgDiv.style.cursor = 'pointer';
                    msgDiv.onclick = () => triggerDownload(url, meta.name);
                }
                // Remove progress stats
                const statsEl = wrap.querySelector('.progress-stats');
                if (statsEl) statsEl.remove();
            }
            delete transferStats[meta.id];
            incomingMeta = null; incomingChunks = []; incomingCount = 0;
        }

        function appendFileProgress(meta, senderName, mode) {
            // Only called for WS relay chunks that arrive without accept flow
            // If the card already exists from file-request, simply update it
            if (document.getElementById(meta.id)) {
                transferStats[meta.id] = { startTime: Date.now(), bytesTransferred: 0 };
                return;
            }

            const wrap = document.createElement('div');
            wrap.className = 'msg-wrapper received';
            wrap.id = meta.id;
            wrap.innerHTML = `
                <div class="msg-nick">${esc(senderName)}</div>
                <div class="msg file-msg" style="flex-direction:column;align-items:stretch;">
                    <div style="display:flex;gap:12px;align-items:flex-start;">
                        <div class="file-icon">ğŸ“„</div>
                        <div class="file-info">
                            <div class="file-name">${esc(meta.name)}</div>
                            <div class="file-meta" id="meta-${meta.id}">${fmtSize(meta.size)} Â· Receiving...</div>
                        </div>
                    </div>
                    <div class="progress-wrap"><div class="progress-bar" id="bar-${meta.id}"></div></div>
                    <div class="progress-stats"><span id="pct-${meta.id}">0%</span><span id="spd-${meta.id}"></span></div>
                </div>`;
            appendToChat(wrap);
            transferStats[meta.id] = { startTime: Date.now(), bytesTransferred: 0 };
        }

        function updateSpeedAndProgress(id, chunksReceived, totalChunks, totalSize) {
            const pct = Math.round((chunksReceived / totalChunks) * 100);
            const bar = document.getElementById('bar-' + id);
            if (bar) bar.style.width = pct + '%';
            const pctEl = document.getElementById('pct-' + id);
            if (pctEl) pctEl.textContent = pct + '%';

            const stats = transferStats[id];
            if (stats) {
                const elapsed = (Date.now() - stats.startTime) / 1000;
                const bytesReceived = (chunksReceived / totalChunks) * totalSize;
                const speed = elapsed > 0 ? bytesReceived / elapsed : 0;
                const spdEl = document.getElementById('spd-' + id);
                if (spdEl) spdEl.textContent = fmtSpeed(speed);
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  HELPERS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function copyCode() {
            navigator.clipboard.writeText(myCode).then(() => sysMsg('Passcode copied to clipboard.'));
        }
        function disconnect() { if (pc) { pc.close(); pc = null; } if (ws) ws.close(); location.reload(); }
        function triggerDownload(url, name) { const a = document.createElement('a'); a.href = url; a.download = name; a.click(); }
        function fmtSize(b) {
            if (b < 1024) return b + ' B';
            if (b < 1048576) return (b / 1024).toFixed(1) + ' KB';
            if (b < 1073741824) return (b / 1048576).toFixed(1) + ' MB';
            return (b / 1073741824).toFixed(1) + ' GB';
        }
        function fmtSpeed(bps) {
            if (bps < 1024) return bps.toFixed(0) + ' B/s';
            if (bps < 1048576) return (bps / 1024).toFixed(1) + ' KB/s';
            return (bps / 1048576).toFixed(1) + ' MB/s';
        }
        function esc(s) { return String(s).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;'); }
        function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

        function bindDragEvents() {
            const chatScreen = document.getElementById('chatScreen');

            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                chatScreen.addEventListener(eventName, e => {
                    e.preventDefault();
                    e.stopPropagation();
                }, false);
            });

            chatScreen.addEventListener('dragenter', () => chatScreen.classList.add('drag-active'), false);
            chatScreen.addEventListener('dragover', () => chatScreen.classList.add('drag-active'), false);
            chatScreen.addEventListener('dragleave', (e) => {
                if (!chatScreen.contains(e.relatedTarget)) {
                    chatScreen.classList.remove('drag-active');
                }
            }, false);

            chatScreen.addEventListener('drop', (e) => {
                chatScreen.classList.remove('drag-active');
                if (!connected) return;

                const file = e.dataTransfer.files[0];
                if (file) {
                    processFileToSend(file);
                }
            }, false);
        }

        window.addEventListener('load', () => {
            connectWS();
            bindDragEvents();
        });
        window.addEventListener('beforeunload', () => { if (pc) pc.close(); if (ws) ws.close(); });
    </script>
</body>

</html>